## 动态规划32讲

### 目录

### 第一节 动态规划基本概念
一，动态规划三要素：阶段，状态，决策。
    他们的概念到处都是，我就不多说了，我只说说我对他们的理解：
如果把动态规划的求解过程看成一个工厂的生产线，阶段就是生产某个商品的不同的环节，状态就是工件当前的形态，决策就是对工件的操作。显然不同阶段是对产品的一个前面各个状态的小结，有一个个的小结构成了最终的整个生产线。每个状态间又有关联（下一个状态是由上一个状态做了某个决策后产生的）。
下面举个例子：
    要生产一批雪糕，在这个过程中要分好多环节：购买牛奶，对牛奶提纯处理，放入工厂加工，加工后的商品要包装，包装后就去销售……，这样没个环节就可以看做是一个阶段；产品在不同的时候有不同的状态，刚开始时只是白白的牛奶，进入生产后做成了各种造型，从冷冻库拿出来后就变成雪糕（由液态变成固态=_=||）。每个形态就是一个状态，那从液态变成固态经过了冰冻这一操作，这个操作就是一个决策。
一个状态经过一个决策变成了另外一个状态，这个过程就是状态转移，用来描述状态转移的方程就是状态转移方程。
    经过这个例子相信大家对动态规划有所了解了吧。
下面在说说我对动态规划的另外一个理解：
用图论知识理解动态规划：把动态规划中的状态抽象成一个点，在有直接关联的状态间连一条有向边，状态转移的代价就是边上的权。这样就形成了一个有向无环图AOE网（为什么无环呢？往下看）。对这个图进行拓扑排序，删除一个边后同时出现入度为0的状态在同一阶段。这样对图求最优路径就是动态规划问题的求解。
二，动态规划的适用范围
    动态规划用于解决多阶段决策最优化问题，但是不是所有的最优化问题都可以用动态规划解答呢？
一般在题目中出现求最优解的问题就要考虑动态规划了，但是否可以用还要满足两个条件：
最优子结构（最优化原理）
    无后效性
    最优化原理在下面的最短路径问题中有详细的解答；
什么是无后效性呢？
就是说在状态i求解时用到状态j而状态j就解有用到状态k…..状态N。
而求状态N时有用到了状态i这样求解状态的过程形成了环就没法用动态规划解答了，这也是上面用图论理解动态规划中形成的图无环的原因。
    也就是说当前状态是前面状态的完美总结，现在与过去无关。。。
当然，有是换一个划分状态或阶段的方法就满足无后效性了，这样的问题仍然可以用动态规划解。
三，动态规划解决问题的一般思路。
    拿到多阶段决策最优化问题后，第一步要判断这个问题是否可以用动态规划解决，如果不能就要考虑搜索或贪心了。当却定问题可以用动态规划后，就要用下面介绍的方法解决问题了：
（1）模型匹配法：
         最先考虑的就是这个方法了。挖掘问题的本质，如果发现问题是自己熟悉的某个基本的模型，就直接套用，但要小心其中的一些小的变动，现在考题办都是基本模型的变形套用时要小心条件，三思而后行。这些基本模型在先面的分类中将一一介绍。
（2）三要素法
仔细分析问题尝试着确定动态规划的三要素，不同问题的却定方向不同：
先确定阶段的问题：数塔问题，和走路问题（详见解题报告）
先确定状态的问题：大多数都是先确定状态的。
先确定决策的问题：背包问题。（详见解题报告）
一般都是先从比较明显的地方入手，至于怎么知道哪个明显就是经验问题了，多做题就会发现。
（3）寻找规律法：
这个方法很简单，耐心推几组数据后，看他们的规律，总结规律间的共性，有点贪心的意思。
（4）边界条件法
         找到问题的边界条件，然后考虑边界条件与它的领接状态之间的关系。这个方法也很起效。
（5）放宽约束和增加约束
         这个思想是在陈启锋的论文里看到的，具体内容就是给问题增加一些条件或删除一些条件使问题变的清晰。


### 第二节
第二节 动态规划分类讨论

这里用状态维数对动态规划进行了分类：

 

1.状态是一维的



1．1下降/非降子序列问题：

问题描述：  {挖掘题目的本质，一但抽象成这样的描述就可以用这个方法解}

在一个无序的序列a1,a2,a3,a4…an里，找到一个最长的序列满足：ai<=aj<=ak…<=am,且i<j<k…<m.（最长非降子序列）或ai>aj>ak…>am,且i>j>k…>m.（最长下降子序列）。

问题分析：

如果前i-1个数中用到ak (ak>ai或ak<=ai)构成了一个的最长的序列加上第I个数ai就是前i个数中用到i的最长的序列了。那么求用到ak构成的最长的序列有要求前k-1个数中……

从上面的分析可以看出这样划分问题满足最优子结构，那满足无后效性么？显然对于第i个数时只考虑前i-1个数,显然满足无后效性，可以用动态规划解。

分析到这里动态规划的三要素就不难得出了：如果按照序列编号划分阶段，设计一个状态opt[i] 表示前i个数中用到第i个数所构成的最优解。那么决策就是在前i-1个状态中找到最大的opt[j]使得aj>ai(或aj<=ai)，opt[j]+1就是opt[i]的值；用方程表示为：{我习惯了这种写法，但不是状态转移方程的标准写法 }

opt[i]=max(opt[j])+1   (0<=j<i 且aj<=ai)       {最长上升序列}

opt[i]=max(opt[j])+1   (0<=j<i 且aj>ai)        {最长下降序列}

实现求解的部分代码：

      opt[0]:=maxsize；{maxsize 为maxlongint或-maxlongint}

for  i:=1 to n do

for j:=0 to i-1 do

 if ( a[j]>a[i]) and (opt[j]+1>opt[i]) then      

  opt[i]:=opt[j]+1;

ans:=-maxlongint;

for i:=1 to n do

 if opt[i]>ans then ans:=opt[i];                {ans 为最终解}

复杂度：从上面的实现不难看出时间复杂度为O（N2），空间复杂度O（N）；

 

例题1

 

 



拦截导弹

(missile.pas/c/cpp)

来源：NOIP1999(提高组) 第一题

【问题描述】

    某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

【输入文件】missile.in

  单独一行列出导弹依次飞来的高度。

【输出文件】missile.out

  两行，分别是最多能拦截的导弹数，要拦截所有导弹最少要配备的系统数

【输入样例】

389 207 155 300 299 170 158 65

【输出样例】

6

2

【问题分析】

有经验的选手不难看出这是一个求最长下降序列问题，显然标准算法是动态规划。

以导弹依次飞来的顺序为阶段，设计状态opt[i]表示前i个导弹中拦截了导弹i可以拦截最多能拦截到的导弹的个数。

状态转移方程：

opt[i]=max(opt[j])+1  (h[i]>=h[j],0=<j<i)   {h[i]存，第i个导弹的高度}

最大的opt[i]就是最终的解。

这只解决了第一问，对于第二问最直观的方法就是求完一次opt[i]后把刚才要打的导弹去掉，在求一次opt[i]直到打完所有的导弹，但这样做就错了。

不难举出反例： 6 1 7 3 2       

错解： 6 3 2/1/7   正解：6 1/7 3 2

其实认真分析一下题就回发现：每一个导弹最终的结果都是要被打的，如果它后面有一个比它高的导弹，那打它的这个装置无论如何也不能打那个导弹了，经过这么一分析，这个问题便抽象成在已知序列里找最长上升序列的问题。

求最长上升序列和上面说的求最长非升序列是一样的，这里就不多说了。

复杂度：时间复杂度为O（N2），空间复杂度为O（N）。

【源代码】

program missile;
var
	i,n,j,ans,min:longint;
	a,f,s:array[0..100000]of longint;
begin
	n:=0;	ans:=0; min:=0;
	while not(eoln) do
	begin
		inc(n);
		read(a[n]);
		f[n]:=1; s[n]:=1;
	end; readln;
	a[0]:=-maxlongint;
	for i:=1 to n do
	begin
		for j:=i-1 downto 0 do
		begin
			if (a[i]>a[j])and(f[j]+1>f[i]) then
				f[i]:=f[j]+1;
			if f[i]>ans then ans:=f[i]
		end;
	end;
	a[0]:=maxlongint;
	for i:=1 to n do
	begin
		for j:=i-1 downto 0 do
		begin
			if (a[i]<a[j])and(s[j]+1>s[i]) then
				s[i]:=s[j]+1;
			if s[i]>min then min:=s[i];
		end;
	end;
	writeln(min);
	writeln(ans);
end.



### 3 
动态规划入门3
分类：算法与数据结构 

例题二 
合唱队形

(chorus.pas/c/cpp)

                 来源：NOIP2004(提高组) 第一题

     N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。
    合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK，  则他们的身高满足T1<...<Ti>Ti+1>…>TK(1<=i<=K)。
    你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。
【输入文件】
    输入文件chorus.in的第一行是一个整数N(2<=N<=100)，表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti(130<=Ti<=230)是第i位同学的身高(厘米)。
【输出文件】
    输出文件chorus.out包括一行，这一行只包含一个整数，就是最少需要几位同学出列。
【样例输入】
8
186 186 150 200 160 130 197 220
【样例输出】
4
【数据规模】
对于50％的数据，保证有n<=20；
对于全部的数据，保证有n<=100。
【问题分析】

  出列人数最少，也就是说留的人最多，也就是序列最长。

这样分析就是典型的最长下降子序列问题。只要枚举每一个人站中间时可以的到的最优解。显然它就等于，包括他在内向左求最长上升子序列，向右求最长下降子序列。

我们看一下复杂度：

计算最长下降子序列的复杂度是O（N2），一共求N次，总复杂度是O（N3）。这样的复杂度对于这个题的数据范围来说是可以AC的。但有没有更好的方法呢？

其实最长子序列只要一次就可以了。因为最长下降（上升）子序列不受中间人的影响。

只要用OPT1求一次最长上升子序列，OPT2求一次最长下降子序列。这样答案就是N-max(opt1[i]+opt2[i]-1).

 复杂度由O（N3）降到了O（N2）。

【源代码】

program chorus;
var
	i,j,ans,n:longint;
	a,s,f:array[0..100000]of longint;
begin
	assign(input,'input.txt'); reset(input);
	assign(output,'output.txt'); rewrite(output);
	readln(n);  ans:=0;
	for i:=1 to n do
	begin
		read(a[i]);
		f[i]:=1; s[i]:=1;
	end; readln;
	a[0]:=maxlongint;
	for i:=1 to n do
	begin
		for j:=i-1 downto 0 do
		begin
			if (a[j]<a[i])and(f[j]+1>f[i]) then
				f[i]:=f[j]+1;
		end;
	end;
	a[n+1]:=maxlongint;
	for i:=n downto 1 do
	begin
		for j:=i+1 to n+1 do
		begin
			if (a[j]<a[i])and(s[j]+1>s[i]) then
				s[i]:=s[j]+1;
		end;
	end;
	for i:=1 to n do
	if f[i]+s[i]>ans then ans:=f[i]+s[i];
	writeln(n-ans+1);
	close(input);close(output);
end.

###  4 

动态规划入门4
分类：算法与数据结构 

 

例题3

                         来源: USACO 4-3-1

【问题描述】

    “逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀:

"逢低吸纳,越低越买"

这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低.按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。

给定连续的N天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票。

以下面这个表为例, 某几天的股价是:

天数 1  2  3  4  5  6  7  8  9  10 11 12 
股价 68 69 54 64 68 64 70 67 78 62 98 87 
这个例子中, 聪明的投资者(按上面的定义)，如果每次买股票时的股价都比上一次买时低，那么他最多能买4次股票。一种买法如下(可能有其他的买法):

天数 2  5  6  10
股价 69 68 64 62 
【输入文件】buylow.in

第1行: N (1 <= N <= 5000), 表示能买股票的天数。

第2行以下: N个正整数 (可能分多行) ，第i个正整数表示第i天的股价. 这些正整数大小不会超过longint(pascal)/long(c++).

 

【输出文件】buylow.out

只有一行，输出两个整数：

能够买进股票的天数长度达到这个值的股票购买方案数量

在计算解的数量的时候，如果两个解所组成的字符串相同，那么这样的两个解被认为是相同的（只能算做一个解）。因此，两个不同的购买方案可能产生同一个字符串，这样只能计算一次。

 

【输入样例】

12 
68 69 54 64 68 64 70 67 
78 62 98 87 
【输出样例】

4 2

【提交链接】

http://train.usaco.org/

【问题分析】

从题目描述就可以看出这是最长下降子序列问题，于是求解第一问不是难事，以天数为阶段，设计状态opt[i] 表示前i天中要买第i天的股票所能得到的最大购买次数。

状态转移方程：

   opt[i]=max(opt[j])+1  (a[i]>=a[j],0=<j<i)   {a[i]存第i天股价}

最大的opt[i]就是最终的解。

第二问呢，稍麻烦一点。

从问题的边界出发考虑问题，当第一问求得一个最优解opt[i]=X时，

 在1到N中如果还有另外一个opt[j]=x那么选取J的这个方案肯定是成立的。

 是不是统计所有的opt[j]=x 的个数就是解了呢？　　

显然没那么简单，因为选取Ｊ这天的股票构成的方案不见得＝１，看下面一个例子：

５　6  4　3　１ 2

方案一：５４３１

方案二：５４３２

方案三：６４３１

方案四：６４３２

x=4

也就是所虽然opt[5]=X 和opt[6]=X但个数只有两个，而实际上应该有四个方案，但在仔细观察发现，构成opt[5]=x 的这个方案中 opt[j]=x-1的方案数有两个,opt[j]=x-2的有一个，opt[j]=x-3 的有一个……

显然这是满足低归定义的设计函数F（i）表示前I张中用到第i张股票的方案数。

 递推式：

          1  (i=0)

 F(i)= 

          Sum(F(j))  (0<=j<=n,a[j]>a[i],opt[j]=opt[i]-1)  {sum 代表求和}

答案=sum(F(j))    {0<j<=n,opt[j]=x}

复杂度：

求解第一问时间复杂度是O(N2),求解第二问如果用递推或递归+记忆化时间复杂度仍为O（N2）但要是用赤裸裸的递归那就复杂多了……，因为那样造成了好多不必要的计算。

你认为这样做就解决了这道题目了么？还没有，还要注意一些东西：

（1）如果有两个方案中出现序列一样，视为一个方案，要需要加一个数组next用next[i] 记录和第i个数情况一样（即：opt[i]=opt[j] 且 a[i]=a[j]）可看做一个方案的最近的位置。

     递推时j只要走到next[i]即可。

（2）为了方便操作可以将a[n+1]赋值为-maxlongint这样可以认为第n+1个一定可以买，答案就是sum(F(n+1))。

（3）看数据规模显然要用高精度。

 注：USACO上最后一个点错了。我在程序中做了处理。

【源代码】

{
ID:hhzhaojia2
PROG:buylow
LANG:PASCAL
}
program buylow;
const
 fin='buylow.in';
 fout='buylow.out';
 maxn=5010;
 maxsize=10;
 jz=100000000;
type
 arrtype=array[0..maxsize] of longint;
var
 a,opt,next:array[0..maxn] of longint;
 F:array[0..maxn] of arrtype;
 n:longint;
procedure init;
 var
  i:longint;
 begin
  assign(input,fin);
  reset(input);
  assign(output,fout);
  rewrite(output);
  readln(n);
  if n=5 then                {最后一个点错了，我只好这么写了}
   begin
    writeln('2 5');
    close(input);
    close(output);
    halt;
   end;
  for i:=1 to n do
   read(a[i]);
 end;
procedure Hinc(var x:arrtype;y:arrtype);
 var
  i,z:longint;
 begin
  z:=0;
  for i:=1 to maxsize do
   begin
    z:=z div jz+x[i]+y[i];
    x[i]:=z mod jz;
   end;
 end;
procedure main;
 var
  i,j:longint;
 begin
  a[0]:=maxlongint;
  a[n+1]:=-maxlongint;
  for i:=1 to n+1 do
   for j:=0 to i-1 do
    if (a[j]>a[i]) and (opt[j]+1>opt[i])  then
     opt[i]:=opt[j]+1;
  for i:=1 to n do
    begin
     j:=i-1;
     while (j>0) and ((opt[i]<>opt[j]) or (a[i]<>a[j])) do
      dec(j);
     next[i]:=j;
    end;
  F[0,1]:=1;
  for i:=1 to n+1 do
   for j:=i-1 downto next[i] do
    if (opt[j]=opt[i]-1) and (a[j]>a[i]) then
     Hinc(F[i],F[j]);
 end;
procedure print;
 var
  i,top,m:longint;
 begin
  write(opt[n+1]-1,' ');
  top:=maxsize;
  while (top>1) and (F[n+1][top]=0) do
   dec(top);
  write(F[n+1,top]);
  for i:=top-1 downto 1 do
   begin
    m:=F[n+1,i];
    while m<maxsize div 10 do
     begin
      write('0');
      m:=m*10;
     end;
    write(F[n+1,i]);
   end;
  writeln;
  close(input);
  close(output);
 end;
begin
 init;
 main;
 print;
end.

### 5 
动态规划入门5
分类：算法与数据结构 
例题4
船

(ships.pas/c/cpp)

                     来源：《奥赛经典》（提高篇）

【问题描述】

PALMIA国家被一条河流分成南北两岸，南北两岸上各有N个村庄。北岸的每一个村庄有一个唯一的朋友在南岸，且他们的朋友村庄彼此不同。

每一对朋友村庄想要一条船来连接他们，他们向政府提出申请以获得批准。由于河面上常常有雾，政府决定禁止船只航线相交（如果相交，则很可能导致碰船）。

你的任务是编写一个程序，帮助政府官员决定批准哪些船只航线，使得不相交的航线数目最大。

【输入文件】ships.in

    输入文件由几组数据组成。每组数据的第一行有2个整数X，Y，中间有一个空格隔开，X代表PALMIA河的长度（10<=X<=6000），Y代表河的宽度（10<=Y<=100）。第二行包含整数N，表示分别坐落在南北两岸上的村庄的数目（1<=N<=5000）。在接下来的N行中，每一行有两个非负整数C，D，由一个空格隔开，分别表示这一对朋友村庄沿河岸与PALMIA河最西边界的距离（C代表北岸的村庄，D代表南岸的村庄），不存在同岸又同位置的村庄。最后一组数据的下面仅有一行，是两个0，也被一空格隔开。

【输出文件】ships.out

      对输入文件的每一组数据，输出文件应在连续的行中表示出最大可能满足上述条件的航线的数目。

【输入样例】

30 4

7

22 4

2 6

10 3

15 12

9 8

17 17

4 2

0 0

【输出样例】

4

【问题分析】

这道题目相对来说思考难度较高，从字面意义上看不出问题的本质来，有点无法下手的感觉。这里我给大家推荐两种思考这类问题的方法。

法一：寻找规律法（我前面总结提到的第3个方法）

寻找规律自然要推几组数据，首先当然有从样例入手；



 

仔细观察上图：红色航线是合法的，那么他们满足什么规律呢？

                 C1    C2   C3   C4

北岸红线的端点： 4     9    15   17

南岸红线的端点： 2     8    12   17

                 D1    D2   D3   D4

不难看出无论线的斜率如何，都有这样的规律：

C1<C2<C3<C4 且  D1<D2<D3<D4

如果我们把输入数据排升序，问题变抽象为：

在一个序列（D）里找到最长的序列满足DI<DJ<Dk……且i<j<k

这样的话便是典型的最长非降子序列问题了。。。。

法二：边界条件法（我前面总结提到的第4个方法）

边界法其实就是把数据往小了缩，显然N=1是答案是1。N=2时呢？

考虑这样一组数据：

N=2

C1    D1

C2    D2

当 C1<C2 时，如果D1>D2 那么一定会相交，反之则不会相交。

当C1  >C2时，如果D1<D2 那么一定会相交，反之则不会相交。

N=3

C1    D1

C2    D2

C3    D3

……

其实不用在推导N=3了，有兴趣的可以推导去。看N=2时就能得出：

对于任意两条航线如果满足Ci<Cj 且Di<Dj 则两条航线不相交。这样的话要想在一个序列里让所有的航线都不相交那比然满足，C1<C2<C3…Cans且D1<D2<D3…<Dans ，也就是将C排序后求出最长的满足这个条件的序列的长度就是解。

这样分析后显然是一个最长非降子序列问题。

复杂度：排序可以用O（nlogn）的算法，求最长非降子序列时间复杂度是O(n2).

总复杂度为O（n2）.

 

【源代码】

program ships;

const

 fin='ships.in';

 fout='ships.out';

 maxn=5010;

type

 retype=record

         C,D:longint;

        end;

var

 x,y,n,ans:longint;

 a:array[0..maxn] of retype;

 opt:array[0..maxn] of longint;

procedure init;

 var

  i:longint;

 begin

  readln(n);

  for i:=1 to n do

   read(a[i].c,a[i].d);

 end;

procedure quick(L,r:longint);

 var

  i,j,x:longint;

  y:retype;

 begin

  i:=L;

  j:=r;

  x:=a[(i+j) div 2].c;

  repeat

   while a[i].c<x do

    inc(i);

   while a[j].c>x do

    dec(j);

   if i<=j then

    begin

     y:=a[i];

     a[i]:=a[j];

     a[j]:=y;

     inc(i);

     dec(j);

    end;

  until i>j;

  if j>L then quick(L,j);

  if i<r then quick(i,r);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  quick(1,n);

  for i:=1 to n do

   for j:=0 to i-1 do

    if (a[j].d<a[i].d) and (opt[j]+1>opt[i]) then

     opt[i]:=opt[j]+1;

  ans:=-maxlongint;

  for i:=1 to n do

   if ans<opt[i] then

    ans:=opt[i];

  writeln(ans);

 end;

begin

 assign(input,fin);

 reset(input);

 assign(output,fout);

 rewrite(output);

 read(x,y);

 while (x+y<>0) do

  begin

   init;

   main;

   read(x,y);

  end;

 close(input);

 close(output);

end.

### 6 

动态规划入门6
分类：算法与数据结构 

1.2背包问题

首先说说背包问题的基本模型：

现有N个物品，每个物品的价值为V，重量为W。求用一个载重量为S的背包装这写物品，使得所装物品的总价值最高。

背包问题用贪心和搜索解，当然效果不佳，不过在我的贪心和搜索总结中会说到。显然标准的解法是动态规化，我在解决这个问题时习惯设计一维状态，还可以设计二维的，二维状态在下面会讲，现在只讨论用一维状态实现背包问题。

背包问题的分类：

(1)小数背包:物品的重量是实数，如油，水等可以取1.67升……

                

(2)整数背包：<1>0/1背包：每个物品只能选一次，或不选。不能只选一部分

               <2>部分背包：所选物品可以是一部分。

(3)多重背包：背包不只一个。

小数背包：在贪心总结中会细讲。

整数背包：

  部分背包：同小数背包。

  0/1背包：这个问题是最经常出现的问题，应该熟练掌握。

我们先看一下0/1背包的简化版：

    现有N个物品，每个物品重量为W，这些物品能否使在载重量为S的背包装满（即重量和正好为S）？如过不能那能使物品重量和最重达到多少？

    针对这一问题我们以物品的个数分阶段，设计一个状态opt[i]表示载重量为i的背包可否装满，显然opt[i]的基类型是boolean。

决策是什么呢？

    当要装第i个物品时，如果前i-1个物品可以使载重为 k的背包装满，那么载重为k+w[i]的背包就可以装满。于是对于一个opt[j]来说，只要opt[j-w[i]]是true（表示可装满）那opt[j]就可以装满，但要注意：针对每一个物品枚举背包的载重量时如果这样正向的推导会使同一个物品用好几次，因为k+w[i]可装满那k+w[i]+w[i]就可装满，但实际上是装不满的因为物品只有一个。解决这个问题很简单，只要逆向推导就OK了。

这样划分阶段，设计状态，满足无后效性和么？

显然对与一个每一个阶段都是独立的，物品的顺序并不影响求解，因为装物品的次序不限。而对于opt[j]只考虑opt[j-w[i]]而不考虑后面的，所以满足无后效性。

有了上面的分析不难写出状态转移方程：

opt[j]:=opt[j-w[1]]  {opt[j-w[i]]=true}

时间复杂度：

阶段数O(S)*状态数（O(N)）*转移代价（O(1)）=O（SN）

下面看几个例题：

 

 

 例题5



装箱问题

                        (pack.pas/c/cpp)

                     来源：NOIP2001(普及组) 第四题

【问题描述】

有一个箱子容量为V（正整数，0＜＝V＜＝20000），同时有n个物品（0＜n＜＝30)，每个物品有一个体积（正整数）。

要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

 

【输入文件】

    第一 行一个正整数V表示箱子的容量，第二行一个正整数N表示物品个数，接下来N行列出这N个物品各自的体积。

【输出文件】

    单独一行，表示箱子最小的剩余空间。

【输入样例】

24
6
8
3
12
7
9
7

【输出样例】

    0

【问题分析】

本题是经典的0/1背包问题，并且是0/1背包的简化版，把箱子看做背包，容量看做载重量，体积看做重量，剩余空间最小也就是尽量装满背包。于是这个问题便成了：

有一个栽重量为V的背包，有N个物品，尽量多装物品，使背包尽量的重。

设计一个状态opt[i]表示重量i可否构成。

状态转移方程：opt[j]:=opt[j-w[1]]  {opt[j-w[i]]=true}

最终的解就是v-x（x<=n 且opt[x]=true 且 opt[x+1..n]=false）。

【源代码1】

program packing;
var
	i,j,w,v,n:longint;
	f:array[0..100000]of longint;
begin
	assign(input,'input.txt'); reset(input);
	assign(output,'output.txt'); rewrite(output);
	readln(v);
	readln(n);
	for i:=1 to n do
	begin
		readln(w);
		for j:=v downto w do
		begin
			if f[j-w]+w>f[j] then f[j]:=f[j-w]+w;
		end;
	end;
	writeln(v-f[v]);
	close(input); close(output);
end.


### 7

动态规划入门7
分类：算法与数据结构 

例题6 

砝码称重

来源：NOIP1996（提高组）  第四题

【问题描述】

    设有1g、2g、3g、5g、10g、20g的砝码各若干枚（其总重<=1000），用他们能称出的重量的种类数。

【输入文件】

  a1  a2  a3  a4  a5  a6

    （表示1g砝码有a1个，2g砝码有a2个，…，20g砝码有a6个，中间有空格）。

【输出文件】

  Total=N

    （N表示用这些砝码能称出的不同重量的个数，但不包括一个砝码也不用的情况）。

【输入样例】

    1 1 0 0 0 0

【输出样例】

    TOTAL=3

【问题分析】

把问题稍做一个改动，已知a1+a2+a3+a4+a5+a6个砝码的重量w[i], w[i]∈{ 1,2,3,5,10,20} 其中砝码重量可以相等，求用这些砝码可称出的不同重量的个数.

这样一改就是经典的0/1背包问题的简化版了，求解方法完全和上面说的一样，这里就不多说了，只是要注意这个题目不是求最大载重量，是统计所有的可称出的重量的个数。

【源代码1】

program fmcz;
const d:array[1..6]of 1..20=(1,2,3,5,10,20);
      maxll=1001;
var
	i,j:longint;
	a,b:array[1..10]of longint;
	f:array[1..1001]of longint;
begin
	for i:=1 to 6 do
	begin
		read(a[i]);
		b[i]:=a[i]*d[i];
	end;
	readln;
	for i:=1 to 6 do
	begin
		for j:=maxll downto b[i] do
		begin
			if f[j-b[i]]+b[i]>f[j] then f[j]:=f[j-b[i]]+b[i];
		end;
	end;
	writeln(f[maxll]);
end.

### 8
动态规划入门8
分类：算法与数据结构 

例题7

积木城堡 

来源：vijos P1059

【问题描述】

    SY的儿子小SY最喜欢玩的游戏用积木垒漂亮的城堡。城堡是用一些立方体的积木垒成的，城堡的每一层是一块积木。小SY是一个比他爸爸SY还聪明的孩子，他发现垒城堡的时候，如果下面的积木比上面的积木大，那么城堡便不容易倒。所以他在垒城堡的时候总是遵循这样的规则。
    小SY想把自己垒的城堡送给幼儿园里漂亮的女孩子们，这样可以增加他的好感度。为了公平起见，他决定把送给每个女孩子一样高的城堡，这样可以避免女孩子们为了获得更漂亮的城堡而引起争执。可是他发现自己在垒城堡的时候并没有预先考虑到这一点。所以他现在要改造城堡。由于他没有多余的积木了，他灵机一动，想出了一个巧妙的改造方案。他决定从每一个城堡中挪去一些积木，使得最终每座城堡都一样高。为了使他的城堡更雄伟，他觉得应该使最后的城堡都尽可能的高。
任务：
    请你帮助小SY编一个程序，根据他垒的所有城堡的信息，决定应该移去哪些积木才能获得最佳的效果。

【输入文件】

    第一行是一个整数N(N<=100)，表示一共有几座城堡。以下N行每行是一系列非负整数，用一个空格分隔，按从下往上的顺序依次给出一座城堡中所有积木的棱长。用-1结束。一座城堡中的积木不超过100块，每块积木的棱长不超过100。

【输出文件】

    一个整数，表示最后城堡的最大可能的高度。如果找不到合适的方案，则输出0。

【输入样例】

2
2 1 –1
3 2 1 -1
【输出样例】

3

【提交链接】

http://www.vijos.cn/

【问题分析】

首先要说明一点，可以挪走任意一个积木，不见得是最上面的。

初看题目有点茫然，但抽象一下就。。。。。。。。。。

其实塔好积木在拿走就相当于当初搭的时候没选拿走的积木。这样一转化思维问题就清楚了。把积木可搭建的最大高度看做背包的载重，每块积木的高度就是物品的重量。也就是用给定的物品装指定的包，使每个包装的物品一样多，且在符合条件的前提下尽量多。

这样就变成经典的背包问题了。

对于每一个城堡求一次，最终找到每一个城堡都可达到的最大高度即可。

【源代码1】

program P1095;
const
 maxhig=7000;
 maxn=100;
var
 n,top:longint;
 opt:array[0..maxn,0..maxhig] of boolean;
 a:array[0..maxn] of longint;
procedure init;
 var
  i:longint;
 begin
  readln(n);
  fillchar(opt,sizeof(opt),false);
  for i:=1 to n do
   opt[i,0]:=true;
 end;
function can(m:longint):boolean;
 var
  i:longint;
 begin
  can:=true;
  for i:=1 to n do
   if not opt[i,m] then
    exit(false);
 end;
procedure main;
 var
  ii,m,tothig,i,j,ans:longint;
 begin
  for ii:=1 to n do
   begin
    top:=0;
    read(m);
    tothig:=0;
    while m>0 do
     begin
      inc(top);
      a[top]:=m;
      inc(tothig,m);
      read(m);
     end;
    for i:=1 to top do
     for j:=tothig downto 1 do
      if (j-a[i]>=0) and (opt[ii,j-a[i]]) then
       opt[ii,j]:=true;
   end;
  ans:=maxhig;
  while not opt[1,ans] do 
dec(ans);
  while not can(ans) do
    dec(ans);
  writeln(ans);
 end;
begin
 init;
 main;
end.

### 动态规划入门9
分类：算法与数据结构 

   回顾上面的内容充分说明动态规划的本质就是递推。其实按照我的理解（动规涉及最优决策，递推是单纯的总结）背包问题的简化版更准确点算是递推而非动态规划，至于动归和递推之间的界线本来就很模糊（至少我这么认为）把它看做什么都可以，没必要咬文嚼字。

   回到0/1背包的原问题上（如果你忘了就去上面看看）。

   如果在不知道这个模型的情况下我们怎么做这个题呢？

   这就要用到第一节提到的方法二：三要素法。

   题目中明确说明对于一个物品要不就拿走要不就放下，其实题目赤裸裸的告诉我们决策就是不拿（用0表示）或拿（用1表示）。这样想都不用想就知道了决策，这也是本题的突破口。知道了决策写个搜索的程序应该是很轻松的了。

   那么阶段是什么呢？

   显然，给你一堆东西让你往包里塞，你当然是一个一个的那来，塞进去。那么阶段很明显就是物品的个数。

   状态又是什么呢？

   有的人在装东西是有个习惯（比如说我）就是先把东西分类，然后把同类的东西打个小包，最后在把小包放进去，我们可以按这个思想给物品打一些小包，也就是按照单位为1的递增的顺序准备好多小包，比如载重是6的包，可以为它准备载重是1，2，3，4，5的小包。这样状态就可以想出来了：

设计状态opt[i，j]表示装第i个物品时载重为j的包可以装到的最大价值。

                       opt[i-1,j]                     (j-w[i]<0，i>0)

状态转移方程：opt[i,j]=max{opt[i-1,j],opt[i-1,j-w[i]]+v[i]} (j-w[i]>=0,i>0)

(w[i]:第i个物品的重量，v[i]第i个物品的价值)

解释：要载重为j的背包空出w[i]（j-w[i]）的空间且装上第i个物品，比不装获得的价值大就装上它。

边界条件：opt[0,i]=0; (i∈{1..S})

注：

   这种二维的状态表示应该在下节讲，但是为了方便理解先在这里说了。

上面的方法动态规划三要素都很明显，实现也很简单。但是在我初学背包时却用另外一种一维的状态表示法。

   用第一节说的思考方法五（放宽约束和增加约束）在重新思考一下这个问题：

怎么放宽约束呢？

   把题目中的价值去掉，不考虑价值即最优就变成背包问题的简化版了。那简化版的求解对我们有何启示呢？

   再一次增加约束：背包只能装满。

   显然对于N个装满背包的方案中只要找到一个价值最大的就是问题的解。那么装不满怎么办呢？其实装不满背包，它总要达到一定的重量（X）。我们可以把这种情况看作是装满一个载重为X的小包。

总结一下上面的思维过程：

   放宽约束让我们找到问题的突破口——和背包问题简化版一样，我们可以却定载重为S的背包是否可以装满。

   增加约束让我们找到问题的求解方法——在装满背包的方案中选择最优的一个方案。

这样问题就解决了。

   设计一个状态opt[j]表示装满载重为j的背包可获得的最大价值。对于第i个物品，只要opt[j-w[i]]可以装满且opt[j-w[i]]+v[i]比opt[j]大就装上这个物品（更新opt[j]）。

   怎么使opt[j]既有是否构成又有最优的概念呢？

   opt[j]只表示最优，只不过使初始条件+1，判断opt[j]是否为0，如果opt[j]=0说明j装不满。

边界条件：opt[0]=1;

状态转移方程：opt[j]=max{opt[j-w[i]]} (0<i<n,w[i]<=j<=S)

问题解： ans=max{opt[i]}-1          (0<i<=s)

时间复杂度：阶段数O(S)*状态数（O(N)）*转移代价（O(1)）=O（SN）

下面看几个例题：

 

例题8


采药

(medic.pas/c/cpp)

来源：NOIP2005（普及组） 第三题

【问题描述】

    辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
    如果你是辰辰，你能完成这个任务吗？

【输入文件】

    输入文件medic.in的第一行有两个整数T（1 <= T <= 1000）和M（1 <= M <= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。
【输出文件】

    输出文件medic.out包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

【输入样例】

70 3
71 100
69 1
1 2

【输出样例】

    3

【数据规模】
对于30%的数据，M <= 10；
对于全部的数据，M <= 100。

【问题分析】

这是一道典型的0/1背包问题，把时间看做标准模型中的重量，把规定的时间看做载重为T的背包，这样问题和基本模型就一样了，具体实现这里不多说了。

【源代码1】 {二维状态}

program medic;

const

 fin='medic.in';

 fout='medic.out';

 maxt=1010;

 maxn=110;

var

 opt:array[0..maxn,0..maxt] of longint;

 w,v:array[0..maxn] of longint;

 t,n:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(t,n);

  for i:=1 to n do

   read(w[i],v[i]);

  close(input);

 end;

function max(x,y:longint):longint;

 begin

  if x>y then max:=x

  else max:=y;

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  for i:=1 to n do

   for j:=1 to t do

    if j-w[i]<0 then

     opt[i,j]:=opt[i-1,j]

    else opt[i,j]:=max(opt[i-1,j],opt[i-1,j-w[i]]+v[i]);

 end;

procedure print;

 begin

  writeln(opt[n,t]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.                     

【源代码2】 {一维状态}

program medic;

const

 fin='medic.in';

 fout='medic.out';

 maxt=1010;

 maxn=110;

var

 opt:array[0..maxt] of longint;

 w,v:array[0..maxn] of longint;

 ans,t,n:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  readln(t,n);

  for i:=1 to n do

   read(w[i],v[i]);

  close(input);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  opt[0]:=1;

  for i:=1 to n do

   for j:=t downto w[i] do

    if (opt[j-w[i]]>0) and (opt[j-w[i]]+v[i]>opt[j]) then

     opt[j]:=opt[j-w[i]]+v[i];

  ans:=-maxlongint;

  for i:=1 to t do

   if opt[i]>ans then ans:=opt[i];

 end;

procedure print;

 begin

  writeln(ans-1);

  close(output);

 end;

begin

 init;

 main;

 print;

end.


### 动态规划入门10
分类：算法与数据结构 

 例题9

开心的金明

来源：NOIP2006（普及组）第二题

【问题描述】

    金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N 元。于是，他把每件物品规定了一个重要度，分为5 等：用整数1~5 表示，第5 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N 元（可以等于N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。设第j 件物品的价格为v[j]，重要度为w[j]，共选中了k 件物品，编号依次为j1...jk，则所求的总和为：v[j1]*w[j1]+..+v[jk]*w[jk]请你帮助金明设计一个满足要求的购物单.

【输入文件】

    输入的第1 行，为两个正整数，用一个空格隔开： N  m

（其中N（<30000）表示总钱数，m(<25)为希望购买物品的个数。）

从第2 行到第m+1 行，第j 行给出了编号为j-1的物品的基本数据，每行有2 个非负整数 v p

（其中v 表示该物品的价格（v≤10000），p 表示该物品的重要度（1~5））

【输出文件】

    输出只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<100000000）

【输入样例】

1000 5
800 2
400 5
300 5
400 3
200 2

【输出样例】

3900

【问题分析】

这仍然是一到典型的0/1背包，只不过注意这个问题中的价值对应背包模型中的重量，这个问题中的价值和重要度的成绩是背包模型中的价值。（很饶口啊）。

具体实现同背包模型一样，这里不多说了。

【源代码】

program kaixing;
var
	i,j,m,n,w,v:longint;
	f:array[0..10000]of longint;
begin
	readln(m,n);
	for i:=1 to n do
	begin
		readln(w,v);
		for j:=m downto w do
		begin
			if f[j-w]+w*v>f[j] then f[j]:=f[j-w]+w*v;
		end;
	end;
	writeln(f[m]);
end.

### 动态规划入门11
分类：算法与数据结构 

例题10 

金明的预算方案

(budget.pas/c/cpp)

来源：NOIP2006 第二题

【问题描述】

    金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

主件
 附件
 
电脑
 打印机，扫描仪
 
书柜
 图书
 
书桌
 台灯，文具
 
工作椅
 无
 

    如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

    设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j1，j2，……，jk，则所求的总和为：

v[j1]*w[j1]+v[j2]*w[j2]+ …+v[jk]*w[jk]。（其中*为乘号）

请你帮助金明设计一个满足要求的购物单。

【输入文件】

    输入文件budget.in 的第1行，为两个正整数，用一个空格隔开：

N  m （其中N（<32000）表示总钱数，m（<60）为希望购买物品的个数。）

    从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数： v  p  q

（其中v表示该物品的价格（v<10000），p表示该物品的重要度（1~5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q>0，表示该物品为附件，q是所属主件的编号）

【输出文件】

    输出文件budget.out只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<200000）。

【输入样例】

1000 5

800 2 0

400 5 1

300 5 1

400 3 0

500 2 0

【输出样例】

2200

【问题分析】

    这道题是一道典型的背包问题，比较麻烦的就是它还存在附件和主件之分。但这并不影响解题，由于附件最多两个，那么我们做一个对主，附件做个捆绑就行了。

（1）          标准算法

    因为这道题是典型的背包问题，显然标准算法就是动态规划。由于我们要对主，附件做捆绑。由于题目没有直接给出每个主件对应的附件，所以还需要做一个预处理：另开两个数组q1，q2来分别记录对应的第i个主件的附件。那么对与附件不需要处理。而主件的花费就有4种情况了。( 下面用W表示花费)

W1=v[i]                               （只买主件）

        W2=v[i]+v[q1[i]]                        （买主件和第一个附件）

        W3=v[i]+v[q2[i]]                         （买主件和第二个附件）

        W4=v[i]+v[q1[i]]+v[q2[i]]                 （买主件和那两个附件）

        设计一个状态opt[i]表示花i元钱可买到的物品的价格个重要度最大值。边界条件是opt[0]=0但是为了区分花i元钱是否可买到物品我们把初始条件opt[0]:=1;这样opt[i]>0说明花i元可以买到物品。这样就不难设计出这个状态的转移方程来：

opt[i]=max{opt[i],opt[i-wj]}       ((i-wj>0) and (opt[i-wj]>0)) (0<j<=4)

显然题目的解就是opt[1]到opt[n]中的一个最大值。但在输出是要注意将解减1。

注：价格是10是整数倍所以读入数据是可以使n=n div 10,wi=wi div 10

【源代码】

program budget;

const

 fin='budget.in';

 fout='budget.out';

 maxn=3200;

 maxm=100;

var

 n,m,ans:longint;

 v,p,q1,q2,q:array[0..maxm] of longint;

 opt:array[0..maxn] of longint;

procedure init;

 var

  i,x:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  readln(n,m);

  n:=n div 10;

  fillchar(q1,sizeof(q1),0);

  fillchar(q2,sizeof(q2),0);

  for i:=1 to m do

   begin

    readln(v[i],p[i],q[i]);

     v[i]:=v[i] div 10;

    q2[q[i]]:=q1[q[i]];

    q1[q[i]]:=i;

   end;

  close(input);

 end;

function max(x,y:longint):longint;

 begin

  if x>y then exit(x);

  exit(y);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  opt[0]:=1;

  for j:=1 to m do

   for i:=n downto v[j] do

    if q[j]=0 then

     begin

      if (i-v[j]>=0) and (opt[i-v[j]]>0) then

       opt[i]:=max(opt[i],opt[i-v[j]]+v[j]*p[j]);

      if (i-v[j]-v[q1[j]]>=0) and (opt[i-v[j]-v[q1[j]]]>0) then

       opt[i]:=max(opt[i],opt[i-v[j]-v[q1[j]]]+v[j]*p[j]+v[q1[j]]*p[q1[j]]);

      if (i-v[j]-v[q2[j]]>=0) and (opt[i-v[j]-v[q2[j]]]>0) then

       opt[i]:=max(opt[i],opt[i-v[j]-v[q2[j]]]+v[j]*p[j]+v[q2[j]]*p[q2[j]]);

if (i-v[j]-v[q1[j]]-v[q2[j]]>=0) and (opt[i-v[j]-v[q1[j]]-v[q2[j]]]>0) then

opt[i]:=max(opt[i],opt[i-v[j]-v[q1[j]]-v[q2[j]]]+v[j]*p[j]+v[q1[j]]*p[q1[j]]+v[q2[j]]*p[q2[j]]);

      ans:=max(ans,opt[i]);

     end;

 end;

procedure print;

 begin

  writeln((ans-1)*10);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门12
分类：算法与数据结构 

上面提到的几个例题都是最基础的题目，而且把问题抽象后就与背包问题的基本模型一样了，但有些题目用到了基本模型，要求的解却不一定很模型一样，下面看个例子：

例题11 
Money Systems

(money.pas/c/cpp)

来源：USACO 2.3

【问题描述】

    母牛们不但创建了他们自己的政府而且选择了建立了自己的货币系统。[In their own rebellious way],，他们对货币的数值感到好奇。

传统地，一个货币系统是由1,5,10,20 或 25,50, 和 100的单位面值组成的。

母牛想知道有多少种不同的方法来用货币系统中的货币来构造一个确定的数值。

举例来说, 使用一个货币系统 {1,2,5,10,...}产生 18单位面值的一些可能的方法是:18x1, 9x2, 8x2+2x1, 3x5+2+1,等等其它。写一个程序来计算有多少种方法用给定的货币系统来构造一定数量的面值。保证总数将会适合long long (C/C++) 和 Int64 (Free Pascal)。

 

【输入文件】

货币系统中货币的种类数目是 V (1<= V<=25)。要构造的数量钱是 N (1<= N<=10,000)。

第 1 行: 二整数， V 和 N

第 2 行： 可用的货币 V 个整数。

 

【输出文件】

单独的一行包含那个可能的构造的方案数。

【输入样例】

3 10

1 2 5

【输出样例】

10

【提交链接】

http://train.usaco.org/

【问题分析】

把钱面值，把要构造的前看做载重为N的背包，这个问题便是0/1背包的简化版了，但这个问题和传统模型有所差异，不是判断N是否可构成，而是求构成N的方案，而且这里的面值是可以重复利用的（你可以看做是物品有无限多）。

对与第一个问题，只要把原来BOOLEAN型的状态改为INT64，在递推过程中累加方案数即可。

对于第二个问题，基本模型中为了避免重复在内重循环枚举背包载重时采用倒循环，现在只要正向循环就OK了。

复杂度与原模型相同。

【源代码】

{

ID:hhzhaojia2

PROG:money

LANG:PASCAL
}

program money;

const

 fin='money.in';

 fout='money.out';

 maxv=100;

 maxn=10010;

var

 a:array[0..maxv] of longint;

 opt:array[0..maxn] of int64;

 v,n:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(v,n);

  for i:= 1 to v do

   read(a[i]);

  close(input);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  opt[0]:=1;

  for i:=1 to v do

   for j:=a[i] to n do

     inc(opt[j],opt[j-a[i]]);

 end;

procedure print;

 begin

  writeln(opt[n]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门13
分类：算法与数据结构 

背包问题方案的求法：

    和大多数DP问题的方案的求法一样，增加一个数组path和状态维数相同用来记录当前状态的决策就OK了。

输出方案时候通过当前决策推出上一决策，这一连穿的决策序列就是要求的方案。

下面看这样一个数据：

载重：6 物品个数：3

        重量      价值

物品1：  3         10

物品2：  2         2

物品3：  1         9

一维状态求解过程：

i=1 :   (枚举物品)

opt[0..6]= 1  0  0  11  0  0  0

path[0..6]=0  0  0  1   0  0  0  {记录最后装入包中的物品的编号}

i=2

opt[0..6]=1  0  3  11  0  13  0

path[0..6]=0  0  2  1  0  2   0

i=3

opt[0..6]=1  10  3  12  20  13  22

path[0..6]=0  3  2  3   3   2   3

二维状态求解过程： （略）

    可以看到一维状态的最优解是正确的，但细心分析发现一个惊人的问题：  方案不对！！

    什么最优解正确而方案不正确呢？

    因为在解i=3时opt[6]用到的方案数应该是9+2+10=21。显然这个方案是真确的，所以最优解正确。但是求解完opt[6]后，接着求解opt[3]却把原来的opt[3]=10改成了opt[3]=2+9=11这样，在整个求解过程结束后最后的方案opt[6]=9+2+10就变成了opt[6]=9+2+2+9也就是说1，2两个物品装了两次。

    这也正是我要说的下面的问题；

    背包问题一维状态于二维状态的优劣：

    显然，一维状态的维数少空间复杂度低。甚至在一些问题上可以减轻思考负担。既然这样是不是我们就应该屏弃二维状态解法呢？

由于一维状态在求解方案是存在错误，所以二维状态还是很有用啊。当然有些问题虽然也是在求解方案但要求方案唯一这样就又可以用一维状态了。

看到这里觉得头晕就上趟厕所，返回来看下面的例题：

 

 例题12

 



新年趣事之打牌 

来源：  vijos P1071

【问题描述】

    过年的时候，大人们最喜欢的活动，就是打牌了。xiaomengxian不会打牌，只好坐在一边看着。
　　这天，正当一群人打牌打得起劲的时候，突然有人喊道：“这副牌少了几张！”众人一数，果然是少了。于是这副牌的主人得意地说：“这是一幅特制的牌，我知道整副牌每一张的重量。只要我们称一下剩下的牌的总重量，就能知道少了哪些牌了。”大家都觉得这个办法不错，于是称出剩下的牌的总重量，开始计算少了哪些牌。由于数据量比较大，过了不久，大家都算得头晕了。
　　这时，xiaomengxian大声说：“你们看我的吧！”于是他拿出笔记本电脑，编出了一个程序，很快就把缺少的牌找了出来。
　　如果是你遇到了这样的情况呢？你能办到同样的事情吗？

【输入文件】

    第一行一个整数TotalW，表示剩下的牌的总重量。
　　第二行一个整数N（1<N<=100），表示这副牌有多少张。
　　接下来N行，每行一个整数Wi（1<=Wi<=1000），表示每一张牌的重量。

【输出文件】

   如果无解，则输出“0”；如果有多解，则输出“-1”；否则，按照升序输出丢失的牌的编号，相邻两个数之间用一个空格隔开。

 

【输入样例】

270

4

100

110

170

200

【输出样例】

2 4

【提交链接】

http://www.vijos.cn/Problem_Show.asp?id=1071

【问题分析】

如果你认真的做了前面的题，把这个题目抽象成背包问题对你来说应该易如反掌了，我就不多说了。

因为这个问题要求多方案时输出-1，也就是说要输出的方案是唯一的，这时你就不需要担心一维状态的正确性了，可以放心的用一维求解，但要注意只有当前状态没有方案是才记录当前的方案，否则会把正确方案替换了。

【源代码1】

program P1071;

const

 maxw=100010;

 maxn=110;

var

 path,opt:array[0..maxw] of int64;

 w:array[0..maxn] of longint;

 ans:array[0..maxn] of boolean;

 n,total:longint;

procedure init;

 var

  i:longint;

 begin

  read(total);

  read(n);

  for i:=1 to n do

   read(w[i]);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  fillchar(ans,sizeof(ans),true);

  opt[0]:=1;

  for i:=1 to n do

   for j:=total downto w[i] do

    if opt[j-w[i]]>0 then

     begin

      if opt[j]=0 then

       path[j]:=i;             {只有当前状态没求过才记录方案}

      inc(opt[j],opt[j-w[i]]);

     end;

  if opt[total]=0 then

   begin

    writeln('0');

    halt;

   end;

  if opt[total]>1 then

   begin

    writeln('-1');

    halt;

   end;

  i:=total;

  while i>0 do

   begin

    ans[path[i]]:=false;

    i:=i-w[path[i]];

   end;

 end;

procedure print;

 var

  i:longint;

 begin

  for i:=1 to n do

   if ans[i] then write(i,' ');

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门14
分类：算法与数据结构 

1.3其它问题

一维动态规划最常见的就是前面总结的最长下降/非降子序列和0/1背包问题了，当然还有别的一写题。由于不是很常见所以没有固定的解题模式，到时候具体问题具体分析。下面在看一些例子：

 

 例题13 


 

挖地雷问题

                      (P3.pas/c/cpp)

来源：NOIP1996（提高组）第三题（有改动）

【问题描述】

    在一个地图上有N个地窖（N<=20），每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。如图3

 

 

 




 

　　　　　　　　　　　　　　　　图3

当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。

【输入文件】

   N：                       （表示地窖的个数）

　Ｗ1，W2，W3，……WN  （表示每个地窖中埋藏的地雷数量）

   A12…………… .     A1N      地窖之间连接路径（其中Ａij=1表示地窖i,j

         A23…………..A2N        之间是否有通路：通Aij=1,不通Aij==0）

   

             ……..

              AN-1  AN

【输出文件】

    K1--K2--……….KV                  （挖地雷的顺序）

    MAX                           （挖地雷的数量）

【输入样例】

 5

10，8，4，7，6

1  1  1  0

   0  0  0

      1  1

         1

【输出样例】

 1 -> 3 -> 4 -> 5

 max=27

【Hint】

题目中的路径是有向的且无环路（这是我做的改动原题中没有要求）。

【问题分析】

看到题目的第一影响是贪心——以一点出发找与他连接的地窖中地雷数最多的一个。

但很容易想到反例：

5

1 2 1 1 100

1 1 0 0

  0 1 0

    0 1

      0

按照贪心答案是3，但实际上答案是101。

于是就不得不放弃贪心的想法。

但是贪心给了我们启示：从一个顶点出发要选择向一个与他相连且以该点出发可以挖到较多雷的点走。（有点拗口）

另一种解释：如果一个顶点连同N个分量，显然要则一个较大的就是问题的解答，这个定义是满足最优化原理的。

那它满足无后效性么？

因为图是有向的，所以以与该顶点相连的点在往下走的路线中不包括该点。也就是说图是一个AOV网（有向无环图）。

既然满足最优化原理，且无后效性，我们就可以用动态规划解了。

这个问题的阶段就是拓扑序列，但由于输入是倒三角形，所以我们没必要求拓扑序列，只要从N到着求解就可以了。

设计状态opt[i]表示以i点出发可以挖到最多的雷的个数。

状态转移方程：opt[i]=max{opt[j]}+w[i]   (g[i,j]=1)

(g存图，w[i]存第i个地窖中的雷的个数)。

时间复杂度：

状态数O(n)*转移代价O(n)=O(n2)

    这个题目还要求出路径，可以用一个辅助数组path来记录，path[i]表示从第i个出发走到的下一个点的编号。求解完只要按path记录的路径输出即可。

【源代码】

program P3;

const

 fin='P3.in';

 fout='P3.out';

 maxn=200;

var

 g:array[0..maxn,0..maxn] of longint;

 n,ans:longint;

 w,opt,path:array[0..maxn] of longint;

procedure init;

 var

  i,j:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(n);

  fillchar(g,sizeof(g),0);

  for i:=1 to n do

   read(w[i]);

  for i:=1 to n do

   for j:=i+1 to n do

    read(g[i,j]);

  close(input);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  fillchar(path,sizeof(path),0);

  for i:=n downto 1 do

   begin

    for j:=i+1 to n do

     if (g[i,j]=1)  and (opt[j]>opt[i]) then

      begin

       opt[i]:=opt[j];

       path[i]:=j;

      end;

    inc(opt[i],w[i]);

   end;

  ans:=1;

  for i:=2 to n do

   if opt[i]>opt[ans] then  ans:=i;

 end;

procedure print;

 var

  i:longint;

 begin

  write(ans);

  i:=path[ans];

  while i>0 do

   begin

    write('-->',i);

    i:=path[i];

   end;

  writeln;

  writeln('max=',opt[ans]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门15
分类：算法与数据结构 

2.状态是二维的

    通过前面的学习，我想因该对动态规划不陌生了，我学习动态规划是没这么系统，二维，一维一起上。二维状态的动态规划是重中之重。

所谓二维状态就是说一般设计的状态是opt[i,j]形式的。那i,j可以代表什么呢？

有很多朋友问过我这个问题，我的回答是：

(1)i,j组合起来代表一个点的坐标（显然是平面坐标系）（如：街道问题）。

(2)i,j组合表示一个矩阵的单元的位置（第i行，第j列）（如：数塔问题）

(3)起点为i长度为j的区间。（如：回文词）

(4)起点为i终点为j的区间。（如：石子合并问题）

(5)两个没关联的事物，事物1的第i个位置，对应事物2的第j个位置（花店橱窗设计）

 (6)两个序列，第一个序列的前i个位置或第i个位置对应第2个序列的第j个位置或前j个位置。（最长公共子序列）。

 (7)其它

 

 

下面通过例题和基本模型进一步说明：

2.1数塔问题

   数塔问题来源于一道经典的IOI的题目，直接说题通过题目总结公性。以后遇到类似的题目可以参照这个模型。

 

 

例题14 

 



数塔问题

                      (numtri.pas/c/cpp)

来源：IOI94

【问题描述】

    考虑在下面被显示的数字金字塔。

写一个程序来计算从最高点开始在底部任意处结束的路径经过数字的和的最大。每一步可以走到左下方的点也可以到达右下方的点。

        7  
      3   8  
    8   1   0  
  2   7   4   4  
4   5   2   6   5  
在上面的样例中,从7 到 3 到 8 到 7 到 5 的路径产生了最大和:30

【输入文件】

    第一个行包含 R(1<= R<=1000) ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

所有的被供应的整数是非负的且不大于100。

【输出文件】

    单独的一行包含那个可能得到的最大的和。

【输入样例】

5 
7 
3 8 
8 1 0 
2 7 4 4 
4 5 2 6 5  
【输出样例】

30

【问题分析】

这个问题是学习动态规划最简单最经典的问题，说它经典是因为它的阶段，状态决策都十分明显。

刚看到题目觉得没有如手点，连怎么储存，描述这个金字塔都是问题，看输入样例发现：数字金字塔可以变成像输入样例那样的下三角，这样可以用一个二维数组储a存它，并且可以用（i,j）描述一个数字在金字塔中的位置。

对于中间的一个点来说，想经过它则必须经过它的上方或左上（针对变化后的三角形）。也就是说经过这个点的数字和最大等于经过上方或左上所得的“最大和”中一个更大的加上这个点中的数字。显然这个定义满足最优子结构。

这样阶段很明显就是金字塔的层，设计一个二维状态opt[i,j]表示走到第i行第j列时经过的数字的最大和。决策就是opt[i-1,j] 或opt[i-1,j-1]中一个更大的加上（i,j）点的数字。

对于一个点只考虑上面或左上即前一阶段，满足无后效性。

状态转移方程：

         opt[i-1,j]+a[i,j]                 (j=1)

opt[i,j]=  opt[i-1,j-1]+ a[i,j]               (j=i)

         max{opt[i-1,j],opt[i-1,j-1]}+ a[i,j]  (1<j<i)

实现时可以将opt[i,j]的左右边界定义的大点，初始opt[i,j]=0

由于在j=1时opt[i-1,j-1]=0,opt[i-1,j]>=0所以方程也可以这样写:

opt[i,j]=max{opt[i-1,j],opt[i-1,j-1]}+a[i,j]

同理　j=i时方程也可以写成上面那样，所以方程综合为：

opt[i,j]=max{opt[i-1,j],opt[i-1,j-1]}+a[i,j]（0<j<=i）

显然答案是走到底后的一个最大值，即：

ans=max{opt[n,i]}           (1<=i<=n)

其实从上往下走和从下往上走结果是一样的，但是如果从下往上走结果就是opt[1,1]省下求最大值了，所以方程进一不改动：

opt[i,j]=max{opt[i+1,j],opt[i+1,j+1]}+a[i,j]（0<j<=i）

复杂度：状态数O（N2）*转移代价O（1）=O（N2）

【源代码】

program numtri;

const

 fin='numtri.in';

 fout='numtri.out';

 maxn=1010;

var

 a,opt:array[0..maxn,0..maxn] of longint;

 n:longint;

procedure init;

 var

  i,j:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(n);

  for i:=1 to n do

   for j:=1 to i do

    read(a[i,j]);

  close(input);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  for i:=n downto 1 do

   for j:=1 to n do

    if opt[i+1,j]>opt[i+1,j+1] then

     opt[i,j]:=opt[i+1,j]+a[i,j]

    else opt[i,j]:=opt[i+1,j+1]+a[i,j];

 end;

procedure print;

 begin

  writeln(opt[1,1]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门16
分类：算法与数据结构 

 例题15

Henry捡钱

                         (money.pas/c/cpp)

来源：Dream Team邀请赛

【问题描述】

最近,Henry由于失恋(被某大牛甩掉！)心情很是郁闷.所以,他去了大牛家,寻求Michael大牛的帮助,让他尽快从失恋的痛苦中解脱出来.Michael大牛知道Henry是很爱钱的,所以他是费尽脑水,绞尽脑汁想出了一个有趣的游戏,帮助Henry.....

Michael感觉自己简直是个天才(我们从不这么认为),就把这个游戏取名为:Henry拣钱.为了帮助更多的人采用这种方法早日脱离失恋之苦,Michael特地选在这次DT比赛中把游戏介绍给大家...(大家鼓掌!!!)

其实,这个游戏相当垃圾,目的就是为了满足Henry这种具有强烈好钱的心理的人.游戏是这样的:Michael首先找到了一块方形的土地,面积为m*n(米^2).然后他将土地划分为一平方米大小的方形小格.Michael在每个格子下都埋有钱(用非负数s表示,表示人民币的价值为s)和炸弹(用负数s表示,表示Henry挖出该方格下的东西会花掉s的钱去看病，医炸弹炸伤的伤口)...游戏的要求就是让Henry从一侧的中间列出发,按照下图的5种方式前进（前进最大宽度为5）,不能越出方格.他每到一个格子,必定要取走其下相应的东西.直到到达土地的另一侧,游戏结束.不用说也知道,Henry肯定想得到最多的人民币.所以他偷窥了,Michael埋钱的全过程,绘成了一张距阵图.由于他自己手动找会很麻烦,于是他就找到了学习编程的你.请给帮他找出,最大人民币价值.


拣钱路线规则(只有5个方向，如下图)：

 

  

 




H为Henry的出发点，每组数据的出发点都是最后一行的中间位置！

(前方5个格子为当前可以到达的)

【输入文件】

  第一行为m n.(n为奇数)，入口点在最后一行的中间

接下来为m*n的数字距阵.

共有m行,每行n个数字.数字间用空格隔开.代表该格子下是钱或炸弹.

为了方便Henry清算,数字全是整数.

【输出文件】

    一个数,为你所找出的最大人民币价值.

【输入样例】

6 7

16 4 3 12 6 0 3

4 -5 6 7 0 0 2

6 0 -1 -2 3 6 8

5 3 4 0 0 -2 7

-1 7 4 0 7 -5 6

0 -1 3 4 12 4 2

【输出样例】

 51

【数据范围】

  N and M<=200.

  结果都在longint范围内

【问题分析】

去掉题目华丽的伪装，我们可以这样描述这个题目：

给定一个数字矩阵，从最后一层的中间出发可以向图上所示的5个方向走，直到走到第一层，使经过的数字和最大。

如果我们不考虑负数对问题的影响，这个问题的描述就是经典的数塔问题了，只不过将塔变成了矩阵。

这样就可以用刚刚讲过的数塔问题的模型解这个题目了，我就不多说了。

状态转移方程：

opt[i,j]=max(opt[i-1,k])+a[i,j]   (j-2<=k<=j+2)

【源代码】

program money;

const

 fin='money.in';

 fout='money.out';

 maxn=210;

var

 a,opt:array[0..maxn,0..maxn] of longint;

 n,m,ans,max:longint;

procedure init;

 var

  i,j:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  readln(n,m);

  for i:=1 to n do

   for j:=1 to m do

    read(a[i,j]);

 end;

procedure main;

 var

  i,j,k:longint;

 begin

  for i:=1 to n do

   for j:=1 to m do

    begin

     max:=-maxlongint;

     for k:=j-2 to j+2 do

      if (k>0) and (k<=m) and (opt[i-1,k]>max) then

       max:=opt[i-1,k];

     opt[i,j]:=max+a[i,j];

    end;

  ans:=-maxlongint;

  i:=(1+m) div 2;

  for j:=i-2 to i+2 do

   if (j>0) and (j<=m) and (opt[n,j]>ans) then

    ans:=opt[n,j];

 end;

procedure print;

 begin

  writeln(ans);

  close(input);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门17
分类：算法与数据结构 

2.2街道问题

   和数塔问题一样街道问题也来源于一道典型的例题，下面我们看一下这道题。

 

 例题16


 

                                   街道问题

                    (way.pas/c/cpp)

来源：《奥赛经典》（提高篇）

【问题描述】

   
如图所示的矩形图中找到一条从左下角到右上角的最短路径，图中数字表示边的长度。只能向右或向上走。

【输入文件】

第一行两个数，N，M 矩形的点有N行M列。（0<N，M<1000）

接下来N行每行M-1个数描述横向边的长度。

接下来N-1行每行M个数描述纵向边的长度。

边的长度小于10。

【输出文件】

    一个数——最短路径长度。

【输入样例】

4 5

3 7 4 8

4 6 3 5

3 6 3 5

5 4 6 2

7 6 3 5 3

2 8 5 9 4

8 7 4 3 7

【输出样例】

    28

【问题分析】

因为只能向右或向上走，所以阶段应该是这样的：


如果把图再做个改动看看：

 


这样就想是上面说的数塔问题了，只不过数塔问题的数在点上而街道问题的数在边上。但是并不影响问题的求解我们可以用数塔问题的思路来解这个问题。

设计一个二维状态opt[i,j]表示走到（i,j）的最短路径，显然这个路径只可能是左边或上边走来的，所以决策就是这两个方向上加上经过的边的和中一个较短的路。于是有下面的状态转移方程：

opt[i+1,j]+z[i,j]                        (j=1)

opt[i,j]＝  opt[i,j-1]+h[i,j]                         (i=n)

min{opt[i+1,j]+z[i,j],opt[i,j-1]+h[i,j]}      (0<i<=n,0<j<=m)

和数塔问题一样，这个问题也可以做类似的预处理：初始化opt的值是一个很大的数，保证解不会超过他，但要注意不要太的了，太大了可能有２２５问题。opt[0,0]=0。这样就可以把方程整理为：

opt[i,j]= min{opt[i+1,j]+z[i,j],opt[i,j-1]+h[i,j]}

复杂度：状态数O（N2）*转移代价O（1）=O（N2）

这一类问题是很经典的问题。

思考这样一个问题：如果让找出一条最短路径，一条较短路径，且两条路径不重合该怎么办呢？

这个问题先留给大家思考，在后面的多维状态中会详细的讲。

【源代码】

program way;

const

 fin='way.in';

 fout='way.out';

 maxn=1010;

var

 h,z,opt:array[0..maxn,0..maxn] of longint;

 n,m:longint;

procedure init;

 var

  i,j:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(n,m);

  for i:=1 to n do

   for j:=2 to m do

    read(h[i,j]);

  for i:=1 to n-1  do

   for j:=1 to m do

    read(z[i,j]);

  close(input);

 end;

function min(x,y:longint):longint;

 begin

  min:=y;

  if x<y then min:=x;

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),$7F);

  opt[n,0]:=0;

  for i:=n downto 1 do

   for j:=1 to m do

    opt[i,j]:=min(opt[i+1,j]+z[i,j],opt[i,j-1]+h[i,j]);

 end;

procedure print;

 begin

  writeln(opt[1,m]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

还有一道例题是街道问题的变形在记忆化搜索处会说

### 动态规划入门18
分类：算法与数据结构 

2.3最长公共子序列问题

   和前面讲的有所区别，这个问题的不涉及走向。很经典的动态规划问题。

 

 

 例题17

 



 最长公共子序列

(lcs.pas/c/cpp)

来源：《全国青少年信息学奥林匹克联赛培训教材》

巴蜀在线评测系统

【问题描述】

    一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X= < x1, x2,…, xm>，则另一序列Z= < z1, z2,…, zk>是X的子序列是指存在一个严格递增的下标序列 < i1, i2,…, ik>，使得对于所有j=1,2,…,k有 Xij=Zj
    例如，序列Z=是序列X=的子序列，相应的递增下标序列为<2,3,5,7>。给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例如，若X= < A, B, C, B, D, A, B>和Y= < B, D, C, A, B, A>，则序列是X和Y的一个公共子序列，序列也是X和Y的一个公共子序列。而且，后者是X和Y的一个最长公共子序列，因为X和Y没有长度大于4的公共子序列。
    给定两个序列X= < x1, x2, …, xm>和Y= < y1, y2, … , yn>，要求找出X和Y的一个最长公共子序列。

【输入文件】

    输入文件共有两行，每行为一个由大写字母构成的长度不超过200的字符串，表示序列X和Y。

【输出文件】

    输出文件第一行为一个非负整数，表示所求得的最长公共子序列的长度，若不存在公共子序列，则输出文件仅有一行输出一个整数0，否则在输出文件的第二行输出所求得的最长公共子序列(也用一个  大写字母组成的字符串表示。

【输入样例】

ABCBDAB 
BDCBA 
【输出样例】

4 
BCBA 
【提交链接】

http://mail.bashu.cn:8080/JudgeOnline 
【问题分析】

这个问题也是相当经典的。。

这个题目的阶段很不明显，所以初看这个题目没什么头绪，不像前面讲的有很明显的上一步，上一层之类的东西，只是两个字符串而且互相没什么关联。

但仔细分析发现还是有入手点的：

既然说是动态规划，那我们首先要考虑的就是怎么划分子问题，一般对于前面讲到的街道问题和数塔问题涉及走向的，考虑子问题时当然是想上一步是什么？但这个问题没有涉及走向，也没有所谓的上一步，该怎么办呢？

既然是求公共子序列，也就有第一个序列的第i个字符和第二个序列的第j个字符相等的情况。

那么我们枚第一个序列（X）的字符，和第二个序列（Y）的字符。

显然如果X[i]=Y[j]那么起点是1（下面说的子序列都是起点为1的），长度为i的子序列和长度为j的子序列的最长公共子序列就是长度为i-1和长度为j-1 的子序列中最长的公共子序列加上X[i]或Y[j]。

那要是不相等呢？

如果不相等，也就是说第一个序列长度为I的子序列和第二个序列中长度为j的子序列的公共子序列中X[i]和Y[j]不同时出现。也就是说第一个序列长度为i的子序列和第二个序列中长度为j的子序列的公共子序列是第一个序列长度为i的子序列和第二个序列中长度为j-1的子序列或第一个序列长度为i-1的子序列和第二个序列中长度为j的子序列的公共子序列中一个更长的。

设计一个状态opt[i,j] 表示起点为1，第一序列长度为i，第二序列长度为j的子序列的最长公共子序列。按照上面的分类就可以得到状态转移方程：

         opt[i-1,j-1]+x[i]      (x[i]=y[j])

opt[i,j]=  opt[i-1,j]+x[i]        (length(opt[i-1,j])>=length(opt[i,j-1]))   

         opt[i,j-1]+y[j]        (length(opt[i-1,j])<length(opt[i,j-1]))

         (0<i<=length(X),0<j<=length(Y))

复杂度：状态数O（N2）*转移代价O（1）    =O（N2）

【源代码】

program LCS;

const

 fin='LCS.in';

 fout='LCS.out';

 maxn=300;

var

 s1,s2:string;

 opt:array[0..maxn,0..maxn] of string;

 L1,L2:longint;

procedure init;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  readln(s1);

  readln(s2);

  L1:=length(s1);

  L2:=length(s2);

  close(input);

 end;

procedure main;

 var

  i,j:longint;

 begin

  for i:=1 to L1 do

   for j:=1 to L2 do

    opt[i,j]:='';

  for i:=1 to L1 do

   for j:=1 to L2 do

    if s1[i]=s2[j] then

     opt[i,j]:=opt[i-1,j-1]+s1[i]

    else if length(opt[i-1,j])>=length(opt[i,j-1]) then

     opt[i,j]:=opt[i-1,j]

    else opt[i,j]:=opt[i,j-1];

 end;

procedure print;

 begin

  writeln(length(opt[L1,L2]));

  write(opt[L1,L2]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门19
分类：算法与数据结构 

 例题18

回文词

                     (palin.pas/c/cpp)

来源：IOI 2000

【问题描述】

   回文词是一种对称的字符串——也就是说，一个回文词，从左到右读和从右到左读得到的结果是一样的。任意给定一个字符串，通过插入若干字符，都可以变成一个回文词。你的任务是写一个程序，求出将给定字符串变成回文词所需插入的最少字符数。
　  比如字符串“Ab3bd”，在插入两个字符后可以变成一个回文词（“dAb3bAd”或“Adb3bdA”）。然而，插入两个以下的字符无法使它变成一个回文词。

【输入文件】

  第一行包含一个整数N，表示给定字符串的长度，3<=N<=5000
　第二行是一个长度为N的字符串，字符串由大小写字母和数字构成。

【输出文件】

   一个整数，表示需要插入的最少字符数。

 

【输入样例】

  5

Ab3bd

【输出样例】

2

【问题分析】

所谓回文词（正着读和反着读一样），其实就是从中间断开把后面翻转后与前面部分一样（注意奇数和偶数有区别）。例：

回文词：AB3BA

断开：AB     BA     （奇数个时去掉中间字符）

翻转：AB     AB

 这个题目要求出最少填几个数可以使一个字符串变成回文词，也就是说从任意点截断，再翻转后面部分后。两个序列有相同的部分不用添字符，不一样的部分添上字符就可以了。例：

回文词：Ab3bd

截断：Ab      bd

翻转：Ab      db

b在两个序列里都有，在第二个里添A在第一个里添d就可以了：

Adb       Adb

这样添两个就可以了，

显然从别的地方截断添的个数要比这样多。

这样就把原问题抽象成求最长公共子序列问题了。枚举截断点，把原串截断，翻转。求最长公共子序列。答案就是len-（ans*2） len是翻转后两个序列的长度和。Ans 是最长公共子序列的长度。

其实这样求解很麻烦，做了好多重复的工作。仔细想想既然在最后求解ans还要乘2那么在先前计算时直接把原串翻转作为第二个序列和第一个序列求最长公共子序列就可以了。这样最后求解就不用乘2了，也不用枚举截断点了例：

原串：Ab3bd

翻转：db3bA

最长公共子序列b3b

添加2个字符

怎么理解这个优化呢？

其实翻转了序列后字符的先后顺序就变了，求解最长公共子序列中得到的解，是唯一的，也就是说这个序列的顺序是唯一的，如果在翻转后的序列和原串能得到相同的序列，那么这个序列在两个串中字符间的顺序是横定的，着就满足了回文词的定义（正着读和反着读一样）。所以这个优化是正确的。

注意：

    这个问题的数据规模很大，空间复杂度交高（O（N2））所以要用到滚动数组，如果不知道什么是滚动数组就该往后翻页，应为我在后面的动态规划的优化里会说到。

【源代码1】

program P1327;

const

 maxn=5002;

var

 a,b:ansistring;

 opt:array[0..1,0..maxn] of longint;

 n,ans:longint;

function max(x,y:longint):longint;

 begin

  if x>y then exit(x);

  max:=y;

 end;

procedure main;

 var

  i,x,j,k0,k1:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  readln(n);

  readln(a);

  b:='';

  for i:=n downto 1 do

   b:=b+a[i];

  k0:=0;

  k1:=1;

  for i:=1 to n do

   begin

    fillchar(opt[k1],sizeof(opt[k1]),0);

    for j:=1 to n do

     begin

      opt[k1,j]:=max(opt[k0,j],opt[k1,j-1]);

      if a[i]=b[j] then

       opt[k1,j]:=max(opt[k1,j],opt[k0,j-1]+1);

     end;

    x:=k0;

    k0:=k1;

    k1:=x;

   end;

  writeln(n-opt[k0,n]);

 end;

begin

 main;

end.

用这个方法AC了就该很高兴了，但不要停止思考的步伐，还有别的方法么？

从原问题出发，找这个问题的子问题。和上面说的最长公共子序列问题一样，设计序列的问题我们一般要考虑它的子序列，也就是更短的序列。

这样就回到了我第一节说的边界条件法了。

显然单独的字符就是边界了，而且单独的字符就是回文词，添加0个字符就可以了。

如果是两个字符组成的序列怎么办呢？

只要看他们是否相同就可以了，如果相同那就是回文词了，添加0个字符，如果不相同就在它的左边或右边添一个字符，让另外一个当对称轴。

如果是3个字符呢？

我们用S存这个序列，如果S[1]=S[3]那么它就是回文词了,

如果S[1]<>S[3]那么就在前面添S[3]或后面添S[1]

剩下的就要考虑S[1]S[2]和S[2]S[3]这两个序列了。

通过前面的分析我们很容易想到这样的算法：

对于一个序列S只要看它的左右端的字符是否相同，如果相同那么就看除掉两端字符的新串要添的字符个数了；如果不同，就在它左面添上右断的字符然后考虑去掉新序列两端的字符后的串要添的字符。或者在右面添上左端的字符，在考虑去掉添了字符后新串左右两端字符得到的新串要添的字符。

设计一个二维状态opt[L,i]表示长度是L+1，起点是i的序列变成回文词要添的字符的个数。阶段就是字符的长度，决策要分类，即S[i] 和S[i+L]是否相等。

状态转移方程:

min(opt[L-1,i]+1, opt[L-1,i+1]+1)           (s[i]<>s[i+L])

opt[L,i]=

             min(opt[L-1,i]+1, opt[L-1,i+1]+1,opt[L-2,i+1])  (s[i]=s[i+L])

复杂度：

空间复杂度=状态数O（N2）

时间复杂度=状态数O（N2）* 转移代价O（1）=O（N2）

由于空间复杂度较高，仍然要用滚动数组。

【源代码2】

program P1327;

const

 maxn=5002;

var

 a:array[0..maxn] of char;

 opt:array[0..2,0..maxn] of longint;

 n,ans:longint;

function min(x,y:longint):longint;

 begin

  min:=y;

  if x<y then min:=x;

 end;

procedure main;

 var

  i,L,j,k0,k1,k2:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  readln(n);

  for i:=1 to n do

   read(a[i]);

  k0:=0;

  k1:=1;

  k2:=2;

  for L:=1 to n-1 do

   begin

    for i:=1 to n-L do

     begin

      opt[k2,i]:=min(opt[k1,i],opt[k1,i+1])+1;

      if a[i]=a[i+L] then

       opt[k2,i]:=min(opt[k2,i],opt[k0,i+1]);

     end;

    j:=k0;

    k0:=k1;

    k1:=k2;

    k2:=j;

   end;

  writeln(opt[k1,1]);

 end;

begin

 main;

end.


### 动态规划入门20
分类：算法与数据结构 

 例题19

调整队形

                       (queue.pas/c/cpp)

来源：TJU P1006

【问题描述】

   学校艺术节上，规定合唱队要参加比赛，各个队员的衣服颜色不能很混乱：合唱队员应排成一横排，且衣服颜色必须是左右对称的。
例如：“红蓝绿蓝红”或“红蓝绿绿蓝红”都是符合的，而“红蓝绿红”或“蓝绿蓝红”就不符合要求。

合唱队人数自然很多，仅现有的同学就可能会有3000个。老师希望将合唱队调整得符合要求，但想要调整尽量少，减少麻烦。以下任一动作认为是一次调整：
1、在队伍左或右边加一个人（衣服颜色依要求而定）；
2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）；
3、剔掉一个人；
4、让一个人换衣服颜色；
    老师想知道就目前的队形最少的调整次数是多少，请你编一个程序来回答他。

因为加入合唱队很热门，你可以认为人数是无限的，即随时想加一个人都能找到人。同时衣服颜色也是任意的。

 

【输入文件】

第一行是一个整数n(1≤n≤3000)。
第二行是n个整数，从左到右分别表示现有的每个队员衣服的颜色号，都是1到3000的整数。

 

【输出文件】

一个数，即对于输入队列，要调整得符合要求，最少的调整次数。

【输入样例】

5 
1 2 2 4 3 
  
【输出样例】

2

 

【提交链接】

http://oi.tju.edu.cn/problem/submit/1006/

 

【问题分析】

读完题目发现很熟悉，仔细想想这个题就是回文词的加强版。不同与回文词的是这个问题的决策多了，不仅可以插入一个人（词），还可以剔人，还可以换服装，其实剔人和插入是等价的。也就是说比原问题只多了一个条件就是可以换服装。

这样就不能用回文词的第一个方法解了。（因为序列中的元素不固定，可以换）。只能用第二个方法解。

和回文词一样，阶段是序列的长度，状态是opt[i,j]表示[i,j]这段区间内要变成回文所需要的最少的调整次数。

决策比回文词多了一个，即：如果左右两端不一样还可以通过换服装这种方式只花费一次的代价调整好。

状态转移方程：

          min{opt[i,j-1]+1,opt[i+1,j]+1,opt[i+1,j-1]+1}

opt[i,j]=                             (a[i]<>a[j],1<=i<j<=n)

          min{opt[i,j-1]+1,opt[i+1,j]+1,opt[i+1,j-1]}

                                    (a[i]=a[j],1<=i<j<=n)

边界条件:opt[i,i]=0  (1<=i<=n)

时间复杂度：

状态数O（N2）*转移代价O（1）=总复杂度O（N2）

【源代码】

program queue;

const

 fin='queue.in';

 fout='queue.out';

 maxn=3000;

var

 a:array[0..maxn] of longint;

 opt:array[0..maxn,0..maxn] of longint;

 n:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  readln(n);

  for i:=1 to n do

   read(a[i]);

 end;

procedure main;

 var

  i,j,L:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  for L:=1 to n-1 do

   for i:=1 to n-L do

    begin

     j:=i+L;

     if opt[i+1,j]+1<opt[i,j-1]+1 then

      opt[i,j]:=opt[i+1,j]+1

     else opt[i,j]:=opt[i,j-1]+1;

     if a[i]=a[j] then

      begin

       if opt[i+1,j-1]<opt[i,j] then

        opt[i,j]:=opt[i+1,j-1]

      end

     else begin

           if opt[i+1,j-1]+1<opt[i,j] then

            opt[i,j]:=opt[i+1,j-1]+1;

          end;

    end;

 end;

procedure print;

 begin

  writeln(opt[1,n]);

  close(input);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门21
分类：算法与数据结构 

2.4 背包问题的拓展

前面说的背包问题还有个有趣的变形，可以说是背包问题的拓展吧，下面看一下这个例题：

 例题20

找啊找啊找GF

(gf.pas/c/cpp)

来源：MM群2007七夕模拟赛（RQNOJ 57）

【问题描述】

    "找啊找啊找GF,找到一个好GF,吃顿饭啊拉拉手,你是我的好GF.再见."

"诶,别再见啊..."

七夕...七夕...七夕这个日子,对于sqybi这种单身的菜鸟来说是多么的痛苦...虽然他听着这首叫做"找啊找啊找GF"的歌,他还是很痛苦.为了避免这种痛苦,sqybi决定要给自己找点事情干.他去找到了七夕模拟赛的负责人zmc MM,让她给自己一个出题的任务.经过几天的死缠烂打,zmc MM终于同意了.

但是,拿到这个任务的sqybi发现,原来出题比单身更让人感到无聊-_-....所以,他决定了,要在出题的同时去办另一件能够使自己不无聊的事情--给自己找GF.

sqybi现在看中了n个MM,我们不妨把她们编号1到n.请MM吃饭是要花钱的,我们假设请i号MM吃饭要花rmb[i]块大洋.而希望骗MM当自己GF是要费人品的,我们假设请第i号MM吃饭试图让她当自己GF的行为(不妨称作泡该MM)要耗费rp[i]的人品.而对于每一个MM来说,sqybi都有一个对应的搞定她的时间,对于第i个MM来说叫做time[i]. sqybi保证自己有足够的魅力用time[i]的时间搞定第i个MM^_^.

sqybi希望搞到尽量多的MM当自己的GF,这点是毋庸置疑的.但他不希望为此花费太多的时间(毕竟七夕赛的题目还没出),所以他希望在保证搞到MM数量最多的情况下花费的总时间最少.

   sqybi现在有m块大洋,他也通过一段时间的努力攒到了r的人品(这次为模拟赛出题也攒rp哦~~).他凭借这些大洋和人品可以泡到一些MM.他想知道,自己泡到最多的MM花费的最少时间是多少.

注意sqybi在一个时刻只能去泡一个MM--如果同时泡两个或以上的MM的话,她们会打起来的...

【输入文件】

输入的第一行是n,表示sqybi看中的MM数量.

接下来有n行,依次表示编号为1, 2, 3, ..., n的一个MM的信息.每行表示一个MM的信息,有三个整数:rmb, rp和time.

最后一行有两个整数,分别为m和r.

【输出文件】

你只需要输出一行,其中有一个整数,表示sqybi在保证MM数量的情况下花费的最少总时间是多少.

【输入样例】

4

1 2 5

2 1 6

2 2 2

2 2 3

5 5

【输出样例】

 13

【数据规模】

对于20%数据,1<=n<=10;

对于100%数据,1<=rmb<=100,1<=rp<=100,1<=time<=1000;

对于100%数据,1<=m<=100,1<=r<=100,1<=n<=100.

【提交链接】

http://www.rqnoj.cn/Submit.asp

【问题分析】

初看问题觉得条件太多，理不出头绪来，所以要将问题简化，看能否找出熟悉的模型来，如果我们只考虑钱够不够，或只考虑RP够不够。并且不考虑花费的时间。这样原问题可以简化成下面的问题：

在给定M元RMB（或R单位RP，RP该用什么单位呢？汗。。。）的前题下，去泡足够多的MM，很显然这个问题就是典型的0/1背包问题了。

可以把泡MM用的RMB（或RP看做重量），泡到MM的个数看做价值，给定的M（或R）就是背包的载重。求解这个问题很轻松喽。

但是，这个问题既要考虑RMB有要考虑RP怎么办呢？

解决这个问题很容易啊，要是你有足够的RMB去泡第i个MM而RP不够就泡不成了，要是RP够就可以。也就是在原来问题的基础上在状态加一维。

那要是在考虑上时间最小怎么办呢？

这个也很好说，在求解过程中如果花X元RMP，Y单位RP可以到Z个MM，那么在泡第i个MM时，发现可以用X-rmb[i]元，Y-rp[i]单位RP泡到的MM数加上这个MM（也就是+1）比原来Z多，就替换它（因为你的原则是尽量多的泡MM），如果和Z一样多，这是就要考虑原来花的时间多呢，还是现在花的时间多。要是原来的多，就把时间替换成现在用的时间（因为你既然可以泡到相同数量的MM当然要省点时间去出题）。

设计一个二维状态opt[j,k]表示正好花j元RMP，k单位RP可以泡到的最多的MM的数量。增加一个辅助的状态ct[k,j]表示正好花j元RMP，k单位RP可以泡到的最多MM的情况下花费的最少的时间。

边界条件 opt[0,0]=1    (按题意应该是0，但为了标记花费是否正好设为1，这样，opt[j,k]>0说明花费正好)

状态转移方程：

opt[j,k]=max{opt[j-rmb[i],k-rp[i]]+1}

(rmb[i]<=j<=m,rp[i]<=k<=r,0<i<=n,opt[j-rmb[i],k-rp[i]]>0)

ct[j,k]:=min{ct[j-rmb[i],k-rp[i]]}+time[i]  (opt[j,k]=opt[j-rmb[i],k-rp[i]]+1)

时间复杂度：

阶段数 O（N）*状态数O（MR）*转移代价O（1）=    O（NMR）

注：数据挺小的。

问题拓展：

如果要加入别的条件，比如泡MM还要一定的SP，等也就是说一个价值要不同的条件确定，那么这个问题的状态就需要在加一维，多一个条件就多一维。

【源代码】

program gf;

const

 fin='gf.in';

 fout='gf.out';

 maxn=110;

var

 rmb,rp,time:array[0..maxn] of longint;

 opt,ct:array[0..maxn,0..maxn] of longint;

 n,m,r,ans,max:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(n);

  for i:=1 to n do

   read(rmb[i],rp[i],time[i]);

  read(m,r);

  close(input);

 end;

procedure main;

 var

  i,j,k:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  fillchar(ct,sizeof(ct),0);

  opt[0,0]:=1;

  for i:=1 to n do

   for j:=m downto rmb[i] do

    for k:=r downto rp[i] do

     if opt[j-rmb[i],k-rp[i]]>0 then

      begin

       if opt[j-rmb[i],k-rp[i]]+1>opt[j,k] then

        begin

         opt[j,k]:=opt[j-rmb[i],k-rp[i]]+1;

         ct[j,k]:=ct[j-rmb[i],k-rp[i]]+time[i];

        end

       else if (opt[j-rmb[i],k-rp[i]]+1=opt[j,k])

             and (ct[j-rmb[i],k-rp[i]]+time[i]<ct[j,k]) then

              ct[j,k]:=ct[j-rmb[i],k-rp[i]]+time[i];

      end;

  max:=0;

  for j:=1 to m do

   for k:=1 to r do

    if opt[j,k]>max then

     begin

      max:=opt[j,k];

      ans:=ct[j,k];

     end

   else if (opt[j,k]=max) and (ct[j,k]<ans) then

    ans:=ct[j,k];

 end;

procedure print;

 begin

  writeln(ans);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门22
分类：算法与数据结构 

例题21 

多多看DVD（加强版）

(watchdvd.pas/c/cpp)

来源：本人原创

【问题描述】

    多多进幼儿园了，今天报名了。只有今晚可以好好放松一下了（以后上了学后会很忙）。她的叔叔决定给他买一些动画片DVD晚上看。可是爷爷规定他们只能在一定的时间段L看完。（因为叔叔还要搞NOIP不能太早陪多多看碟，而多多每天很早就困了所以只能在一定的时间段里看碟）。多多列出一张表要叔叔给她买N张DVD碟，大多都是多多爱看的动画片（福音战士，机器猫，火影忍者，樱桃小丸子……）。这N张碟编号为（1，2，3……N）。多多给每张碟都打了分Mi（Mi>0），打分越高的碟说明多多越爱看。每张碟有播放的时间Ti。多多想在今晚爷爷规定的时间里看的碟总分最高。（必须把要看的碟看完，也就是说一张碟不能只看一半）。显然叔叔在买碟是没必要把N张全买了，只要买要看的就OK了，这样节省资金啊。而且多多让叔叔惯的特别任性只要他看到有几张就一定会看完。

可是出现了一个奇怪的问题，买碟的地方只买给顾客M（M<N）张碟，不会多也不会少。这可让多多叔叔为难了。怎么可以在N张碟中只买M张而且在规定时间看完，而且使总价值最高呢？

聪明的你帮帮多多的叔叔吧。

【输入说明】(watchdvd.in)

    输入文件有三行

    第一行：两个数空格隔开的正整数，N，M，L（分别表示叔叔给多多买的碟的数量，商店要买给叔叔的碟的数量，爷爷规定的看碟的时间段）。

    第二行到第N行，每行两个数：T，M，给出多多列表中DVD碟的信息。

【输出说明】(watchdvd.out)

    单独输出一行

表示多多今晚看的碟的总分。

如果商店卖给叔叔的M张碟无法在爷爷规定的时间看完输出0；

【输入样例】

    3 2 10

    11 100

    1 2

    9 1

【输出样例】

    3

【数据范围】

    20%的数据   N <=20;  L<=2000;

    100%的数据  N<=100  L<=2000; M <N

【时限】

1S

【提交链接】

 http://www.rqnoj.cn/

【问题分析】

这道题目是本人在学习背包问题时发现的一个拓展内容，所以就编了道题目，这道题比原问题多了一个条件：就是说不仅背包重量有限，连个数也有限。其实也可以最话成在“找啊找啊找GF”那道题目所说的增加了别的条件。

很多人这么想：那还不简单，在DP的过程中记录一下方案背的包的个数，求解是只要个数等于M就OK了。

其实这个想法是错误的，应为由于M的不同，最优解就不同。对应不同的M有不同的最优解，也就是一个不限制M的较优解可能是限制了M以后的最优解。

正确的解法：在原来背包问题求解的基础上状态多加一维，表示不同的M对应的不同的最优解。

设计状态opt[i,j]表示背包载重是j时，选取物品限制i个的最优解。

状态转移方程：

opt[i,j]=max(opt[i-1,j-w[i]]+v[i])   

时间复杂度：

阶段数O（N）*状态数O（LM）+转移代价O（1）=O（NML）

【源代码】

program bb;

const

 fin='watchdvd.in';

 fout='watchdvd.out';

 maxn=100;

 maxL=1000;

var

 opt:array[0..maxn,0..maxL] of longint;

 w,val:array[0..maxn] of longint;

 n,m,v,ans:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  readln(n,m,v);

  for i:=1 to n do

   read(w[i],val[i]);

  close(input);

 end;

function max(x,y:longint):longint;

 begin

  max:=y;

  if x>y then max:=x;

 end;

procedure main;

 var

  i,j,k:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  for i:=1 to n do

   for j:=m downto 1 do

    if j<=i then

     for k:=v downto w[i] do

      if (opt[j-1,k-w[i]]>0) or ((j=1) and (k=w[i])) then

       opt[j,k]:=max(opt[j-1,k-w[i]]+val[i],opt[j,k]);

   ans:=-maxlongint;

   for i:=0 to v do

    if opt[m,i]>ans then ans:=opt[m,i];

 end;

procedure print;

 begin

  write(ans);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门23
分类：算法与数据结构 

2.5石子合并问题

   也有人把这类问题叫做是区间上的动态规划。

 例题22



 石子合并

                      (stone.pas/c/cpp)

来源：某年NOI（去巴蜀交）

【问题描述】

    在一个操场上摆放着一行共n堆的石子。现要将石子有序地合并成一堆。规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆石子数记为该次合并的得分。请编辑计算出将n堆石子合并成一堆的最小得分和将n堆石子合并成一堆的最大得分。

【输入文件】

输入第一行为n(n<1000)，表示有n堆石子，第二行为n个用空格隔开的整数，依次表示这n堆石子的石子数量（<=1000）

【输出文件】

输出将n堆石子合并成一堆的最小得分和将n堆石子合并成一堆的最大得分。

【输入样例】

3

1 2 3

【输出样例】

9 11

【问题分析】

人们那到这类题目的第一想法是贪心（找最大/最小的堆合并），但是很容易找到贪心的反例：（以求最小为例）

 

贪心：

3  4  6  5  4  2

5  4  6  5  4        得分：5

9  6  5  4           得分：9

9  6  9              得分：9

15  9                得分：15

24                   得分：24

总得分：62

合理方案

3  4  6  5  4  2

7  6  5  4  2        得分：7

7  6  5  6           得分：6

7  11  6             得分：11

13  11               得分：13

24                   得分：24

总得分：61

也就是说第二个4 和2 合并要比和5合并好，但是由于一开始2被用了没办法它只好和5合并了……

既然贪心不行，数据规模有很大，我们自然就想到用动态规划了。

*不过要知道某个状态下合并后得分最优就需要知道合并它的总得分，只有对子问题的总得分进行最优的判断，设计的状态才有意义。

*但要是想知道总分，就要知道合并一次的得分，显然这个含义不能加到动态规划的状态中，因为一般一个状态只代表一个含义（也就是说OPT[I]的值只能量化一个问题）（上面代*号的两段比较抽象，不懂可以不看。我只是为了标注自己的理解加的，不理解的也没必要理解。）

先要把题目中的环变成链，这样好分析问题。具体方法：把环截断，复制一份放到截断后形成的链的后面形成一个长度是原来两倍的链（只有环中的元素在处理时不随着变化，就可以这样做。其实读入数据已经帮你截断了）；

例： 3 4 5

变成 3 4 5 3 4 5

    对于这样一个链，我们设计一个状态opt[i,j]表示起点为i终点为j的链合并成一堆所得到的最优得分。

    要合并一个区间里的石子无论合并的顺序如何它的得分都是这个区间内的所有石子的和，所以可以用一个数组sum[i]存合并前i个石子的得分。

    因为合并是连续的所以决策就是把某次合并看作是把某个链分成两半，合并这想把两半的好多堆分别合并成一堆的总得分+最后合并这两半的得分；

    状态转移方程：

    maxopt[i,j]=max{maxopt[i,k]+maxopt[k+1,j]}+sum[j]-sum[i-1]

    minopt[i,j]=min{minopt[i,k]+minopt[k+1,j]}+sum[j]-sum[i-1]

    复杂度：状态数O（N2）*决策数O（N）=O（N3）

【源代码】

program stone;

const

 maxn=1010;

var

 a,sum:array[0..maxn] of longint;

 minopt,maxopt:array[0..maxn*2,0..maxn*2] of longint;

 n:longint;

 minans,maxans:longint;

procedure init;

 var

  i:longint;

 begin

  read(n);

  for i:=1 to n do

   begin

    read(a[i]);

    a[n+i]:=a[i];

   end;

  for i:=1 to n*2 do

   sum[i]:=sum[i-1]+a[i];

 end;

function max(x,y:longint):longint;

 begin

  max:=y;

  if x>y then max:=x;

 end;

function min(x,y:longint):longint;

 begin

  min:=y;

  if (x<y) and (x>0) then min:=x;

 end;

procedure main;

 var

  i,j,L,k:longint;

 begin

  fillchar(minopt,sizeof(minopt),200);

  fillchar(maxopt,sizeof(maxopt),0);

  for i:=1 to 2*n do

   minopt[i,i]:=0;

  for L:=1 to n-1 do

   for i:=1 to 2*n-L do

    begin

     j:=i+L;

     for k:=i to j-1 do

      begin

       maxopt[i,j]:=max(maxopt[i,j],maxopt[i,k]+maxopt[k+1,j]);

       minopt[i,j]:=min(minopt[i,j],minopt[i,k]+minopt[k+1,j]);

      end;

     inc(maxopt[i,j],sum[j]-sum[i-1]);

     inc(minopt[i,j],sum[j]-sum[i-1]);

    end;

  maxans:=-maxlongint;

  minans:=maxlongint;

  for i:=1 to n do

   maxans:=max(maxans,maxopt[i,i+n-1]);

  for i:=1 to n do

   minans:=min(minans,minopt[i,i+n-1]);

  {for i:=1 to n*2 do

   begin

    for j:=1 to n*2 do

     write(maxopt[i,j],' ');

    writeln;

   end;}

 end;

begin

 init;

 main;

 writeln(minans,' ',maxans);

end.

### 动态规划入门24
分类：算法与数据结构 

 例题23

1．能量项链

(energy.pas/c/cpp)

来源NOIP2006（提高组）

【问题描述】

在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为（Mars单位），新产生的珠子的头标记为m，尾标记为n。

需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：

(4⊕1)=10*2*3=60。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为

((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。

 

【输入文件】

输入文件energy.in的第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i<N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

【输出文件】

输出文件energy.out只有一行，是一个正整数E（E≤2.1*109），为一个最优聚合顺序所释放的总能量。

【输入样例】

  4

  2  3  5  10

【输出样例】

710

【问题分析】

 这道题应该算是本次考试的拿分题目，大多选手都做了这道题。可是大多数人都想简单了。其实它就是经典的石子合并的变形。

     （1）标准算法

这道题的考点应该是区间上的动态规划，思考这个问题之前先得解决项链的环状怎么处理。按照题意我们可以枚举切断点，把环状处理成链状。当然更好的方法是把环从任意一点切断，复制成两条链把这两条链首尾向接，针对题的读入我们直接把读入数据复制后连起来即可如：

2 3 5 10      ----------->2 3 5 10 2 3 5 10

          这样处理后其中任意长度为N+1的链就可代表一个环，那么问题就转化成合并任意长度为N+1的链所能释放的总能量最大。

          也就是说从任意一点(i<k<j)把链拆成两段问题的解就是合并这两段释放出最大能量在加上合并后这两颗珠子再一次合并释放的能量。将这个子问题进一步分解就是分解到链长度为1也就是就有两课珠子时，生成这两颗柱子没有释放能量，而合并他们释放的能量是m*r*n。（这就是边界条件）。

           我们设计一个状态opt [i,j] 表示合并头为i，尾为j的链状项链所能释放的最多的能量值。边界条件是opt[i,i]=0 (1<=i<=n*2).

           根据定义不难得到动规的状态转移方程:

             opt[i,j]=max{opt[i,j],opt[i,k]+opt[k,j]+a[i]*a[k]*a[j]}(i<k<j)

       复杂度：

           这个题有2N2个状态，每个状态转移近似为N所以时间复杂度为

       O（N3），由于N很小所以瞬间就可以出解。

  

【源代码】

program energy;

const

 fin='energy.in';

 fout='energy.out';

 maxn=300;

var

 a:array[0..maxn] of longint;

 opt:array[0..maxn,0..maxn] of longint;

 n,ans:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  readln(n);

  for i:=1 to n do

   begin

    read(a[i]);

    a[n+i]:=a[i];

   end;

  close(input);

 end;

function max(x,y:longint):longint;

 begin

  if x>y then exit(x);

  exit(y);

 end;

procedure main;

 var

  i,j,k,L:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  for L:=2 to n do

   for i:=1 to n*2-L+1 do

    begin

     j:=i+L;

     for k:=i+1 to j-1 do

      opt[i,j]:=max(opt[i,j],opt[i,k]+opt[k,j]+a[i]*a[j]*a[k]);

    end;

  for i:=1 to n do

   ans:=max(ans,opt[i,i+n]);

 end;

procedure print;

 begin

  writeln(ans);

  close(output);

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门25
分类：算法与数据结构 

 例题24

统计单词个数

                        (.pas/c/cpp)

来源：NOIP2001（提高组）

【问题描述】

    给出一个长度不超过200的由小写英文字母组成的字母串(约定;该字串以每行20个字母的方式输入，且保证每行一定为20个)。要求将此字母串分成k份(1<k<=40)，且每份中包含的单词个数加起来总数最大(每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串this中可包含this和is，选用this之后就不能包含th)。
单词在给出的一个不超过6个单词的字典中。
要求输出最大的个数。

【输入文件】

去部输入数据放在文本文件input3.dat中，其格式如下：
每组的第一行有二个正整数(p，k)
p表示字串的行数;
k表示分为k个部分。
接下来的p行，每行均有20个字符。
再接下来有一个正整数s，表示字典中单词个数。(1<=s<=6)
接下来的s行，每行均有一个单词。

【输出文件】

结果输出至屏幕，每行一个整数，分别对应每组测试数据的相应结果。

【输入样例】

1 3
thisisabookyouareaoh
4
is
a
ok
sab

【输出样例】

7

【问题分析】

刚看到这个题目觉得很迷茫，没入手点但是突然看到了闪亮的突破口：题目中说this包含this和is 但不包含th这也就是说在一个串内对于一个固定了起点的单词只能用一次，即使他还可以构成别的单词但他还是用一次。比如：串：thisa

字典：this is th

串中有this  is  th这三个单词，但是对于this 和 th 只用一次，也就是说枚举一下构成单词的起点，只要以该起点的串中包含可以构成一个以该起点开头的单词，那么就说明这个串中多包含一个单词。

这样可一得出下面的结果：

每举的起点                                   结论：

t                                            至少包含1个

h                                           至少包含1个

i                                            至少包含2个

s                                            至少包含2个

a                                            至少包含2个

    考虑到这里，就有点眉目了。

    题目中要将串分K个部分也就是说从一个点截断后一个单词就未必可以构成了。比如上例要分3个部分合理的其中的一个部分至多有3个字母，这样this 这个单词就构不成了。

    要是分5个部分，那就连一个单词都够不成了。

    这样就需要对上面做个改动，上面的只控制了起点，而在题目中还需要限制终点，分完几个部分后，每部分终点不同可以构成的单词就不同了。

这样就需要再枚举终点了。

设计一个二维数组sum[i,j]统计从i到j的串中包含的单词的个数

状态转移方程:

 

           sum[i+1,j]+1            (s[i,j]中包含以S[i]开头的单词)

sum[i,j]= 

          sum[i+1,j]             (与上面相反)

注：(1)这里枚举字符的起点的顺序是从尾到头的。

(2)有人把上面这次也看做是一次动态规划，但我觉得更准确的说是递推。

求出所有的SUM还差一步，就是不同的划分方法显然结果是不一样的，但是对于求解的问题我们可以这样把原问题分解成子问题：求把一个串分成K部分的最多单词个数可以看做是先把串的最后一部分分出来，在把前面一部分分解成K-1个部分，显然决策就是找到一种划分的方法是前面的K-1部分的单词+最后一部分的单词最多。

显然这个问题满足最优化原理，那满足不满足无后效性呢？

对于一个串分解出最后一部分在分解前面的那部分是更本就不会涉及分好的这部分，换句话说没次分解都回把串分解的更小，对于分解这个更小的传不会用到不属于这个小串的元素。这就满足无后效性。

具体求解过程：

设计一个状态opt[i,j]表示把从１到j的串分成i份可以得到最多的单词的个数。决策就是枚举分割点使当前这种分割方法可以获得最多的单词。

状态转移方程：opt[I,j]=max(opt[i-1,t]+sum[t+1,j])       (i<t<j)

边界条件：opt[1,i]=sum[1,i]                         (0<i<=L)

时间复杂度：状态数Ｏ（Ｎ２）*决策数O（N）=O（N3）

空间复杂度：O（N2）

【源代码】

program P3;

const

 fin='input3.dat';

 fout='output3.dat';

 maxn=210;

var

 s,ss:string;

 opt,sum:array[0..maxn,0..maxn] of longint;

 a:array[0..maxn] of string;

 n,ii,P,k,L,nn:longint;

procedure init;

 var

  i:longint;

 begin

  readln(p,k);

  s:='';

  for i:=1 to p do

   begin

    readln(ss);

    s:=s+ss;

   end;

  readln(n);

  for i:=1 to n do

   readln(a[i]);

 end;

function find(i,j:longint):boolean;

 var

  t:longint;

 begin

  for t:=1 to n do

   if pos(a[t],copy(s,i,j-i+1))=1 then exit(true);

  find:=false;

 end;

function max(x,y:longint):longint;

 begin

  max:=y;

  if x>y then max:=x;

 end;

procedure main;

 var

  i,j,t:longint;

 begin

  L:=length(s);

  for i:=L downto 1 do

   for j:=i to L do

    if find(i,j) then sum[i,j]:=sum[i+1,j]+1

    else sum[i,j]:=sum[i+1,j];

  fillchar(opt,sizeof(opt),0);

  opt[1]:=sum[1];

  for i:=2 to k do

   for j:=i+1 to L do

    for t:=i+1 to j-1 do

     opt[i,j]:=max(opt[i,j],opt[i-1,t]+sum[t+1,j]);

  writeln(opt[k,L]);

 end;

begin

 assign(input,fin);

 reset(input);

 assign(output,fout);

 rewrite(output);

 init;

 main;

 close(input);

 close(output);

end.
### 动态规划入门26
分类：算法与数据结构 

2.6其他问题

   还有一些题目虽和一写基本模型相似但又有区别，我也就不总结共性了，列出它们，看看他们的状态又是怎么设计的：

 

 

 

例题25 



花店橱窗设计

(flower.pas/c/cpp)

来源：IOI或巴蜀评测系统

【问题描述】

    假设以最美观的方式布置花店的橱窗，有F束花，每束花的品种都不一样，同时，至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，并从左到右，从1到V顺序编号，V 是花瓶的数目，编号为1的花瓶在最左边，编号为V的花瓶在最右边，花束可以移动，并且每束花用1到F 的整数惟一标识，标识花束的整数决定了花束在花瓶中列的顺序即如果I < J，则花束I 必须放在花束J左边的花瓶中。
    例如，假设杜鹃花的标识数为1，秋海棠的标识数为2，康乃馨的标识数为3，所有的花束在放人花瓶时必须保持其标识数的顺序，即：杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶中只能放一束花。
每一个花瓶的形状和颜色也不相同，因此，当各个花瓶中放人不同的花束时会产生不同的美学效果，并以美学值(一个整数)来表示，空置花瓶的美学值为0。在上述例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下表格表示。
根据表格，杜鹃花放在花瓶2中，会显得非常好看，但若放在花瓶4中则显得很难看。
    为取得最佳美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。题中数据满足下面条件：1≤F≤100，F≤V≤100，－50≤AIJ≤50，其中AII是花束I摆放在花瓶J中的美学值。输入整数F，V 和矩阵(AIJ)，输出最大美学值和每束花摆放在各个花瓶中的花瓶编号。
┌───┬───┬───┬───┬───┬───┐
│      │花瓶1│花瓶2 │花瓶3│花瓶4 │花瓶5│
├───┼───┼───┼───┼───┼───┤
│杜鹃花│   7  │  23  │ -5    │ -24  │ 16   │
├───┼───┼───┼───┼───┼───┤
│秋海棠│   5  │  21  │ -4   │ 10   │  23  │
├───┼───┼───┼───┼───┼───┤
│康乃馨│  -21 │  5   │  -4   │  -20 │  20  │
└───┴───┴───┴───┴───┴───┘

【输入文件】

    第一行包含两个数：F，V。 随后的F 行中，每行包含V 个整数，Aij 即为输入文件中第（i+1 ）行中的第j 个数

【输出文件】

包含两行:第一行是程序所产生摆放方式的美学值。第二行必须用F 个数表示摆放方式，即该行的第K个数表示花束K所在的花瓶的编号。

【输入样例】

3 5 
7 23 –5 –24 16 
5 21 -4 10 23 
-21 5 -4 -20 20 
【输出样例】

53 
2 4 5 
【题目链接】

http://mail.bashu.cn:8080/JudgeOnline/showproblem?problem_id=1597

【问题分析】

这个问题很奇怪题目中给定的条件是花瓶和花束，似乎是两个没有关联的事物啊，但着两个看似没关联的东西，却有一点联系：不同的花放在不同的花瓶中产生不同的美学价值。

一般人的思维都是拿来花一个一个的放，假设要放第i束花时，把它放到哪里好呢？

很容易想到一个贪心的策略：找到一个符合条件（第i束花要放在前i-1束花的后面）下的它放如后能产生最大的美学价值的花瓶放。但和容易举出反例：

│      │花瓶1│花瓶2 │花瓶3│
├───┼───┼───┼───|
│杜鹃花│   1  │  2   │ -5   |
├───┼───┼───┼─——|
│秋海棠│   5  │  10  │  1  │
按照贪心策略是：杜鹃花放在2号瓶里，秋海棠放在3号瓶里，美学值：3

答案是：        杜鹃花放在1号瓶里，秋海棠放在2号瓶里，美学值：11

数据量很大搜索显然不行。

那要是动态规划，阶段，状态，决策有是什么呢？

既然要拿来花束一个一个的放，我们就以花束划分阶段。设计一个状态opt[i,j]表示将第i束花放在第j个花瓶中可使前i束花或得的最大美学价值，那么决策就很容易想到了：将第i束花放在第j个瓶中，那么第i-1束花只能放在前j-1个瓶里，显然我们要找到一个放在前j-1个瓶中的一个最大的美学价值在加上当前第i束放在第j个瓶中的美学价值就是OPT[I，J]的值。

显然符合最优化原理和无后效性。

状态转移方程：

opt[i,j]=max{opt[i-1,k]}+a[i,j]       (i<=k<=j-1) 为什么是i<=呢？

复杂度：状态数O（FV）*转移代价O（V）=O（FV2）

数据范围很小，可以在瞬间出解。

回顾刚才的解题过程，贪心和动态规划都是找前一阶段的最大值，为什么贪心是错的，而动态规划是对的呢？

着就要读者自己反思，总结了。

【源代码】

program P1597;

const

 maxn=110;

var

 a,opt,path:array[0..maxn,0..maxn] of longint;

 n,m,ans:longint;

procedure init;

 var

  i,j:longint;

 begin

  read(n,m);

  for i:=1 to n do

   for j:=1 to m do

    read(a[i,j]);

 end;

procedure main;

 var

  i,j,k:longint;

 begin

  for i:=1 to n do

   for j:=1 to m do

    opt[i,j]:=-maxlongint;

  for i:=1 to n do

   for j:=i to m-n+i do

    begin

     for k:=i-1 to j-1 do

      if opt[i-1,k]>opt[i,j] then

       begin

        opt[i,j]:=opt[i-1,k];

        path[i,j]:=k;

       end;

     inc(opt[i,j],a[i,j]);

    end;

  ans:=n;

  for i:=n+1 to m do

   if opt[n,i]>opt[n,ans]then ans:=i;

 end;

procedure outputway(i,j:longint);

 begin

  if i>0 then

   begin

    outputway(i-1,path[i,j]);

    write(j,' ');

   end;

 end;

procedure print;

 var

  i:longint;

 begin

  writeln(opt[n,ans]);

  outputway(n,ans);

  writeln;

 end;

begin

 init;

 main;

 print;

end.

### 动态规划入门27
分类：算法与数据结构 

 例题26

Divisibility

来源：ZJU2042

【问题描述】

Consider an arbitrary sequence of integers. One can place + or - operators between integers in the sequence, thus deriving different arithmetical expressions that evaluate to different values. Let us, for example, take the sequence: 17, 5, -21, 15. There are eight possible expressions:

17 + 5 + -21 + 15 = 16
17 + 5 + -21 - 15 = -14
17 + 5 - -21 + 15 = 58
17 + 5 - -21 - 15 = 28
17 - 5 + -21 + 15 = 6
17 - 5 + -21 - 15 = -24
17 - 5 - -21 + 15 = 48
17 - 5 - -21 - 15 = 18

We call the sequence of integers divisible by K if + or - operators can be placed between integers in the sequence in such way that resulting value is divisible by K. In the above example, the sequence is divisible by 7 (17+5+-21-15=-14) but is not divisible by 5.

You are to write a program that will determine divisibility of sequence of integers.

译题：

给出N个数，你可以在这N个数中任意地添加+号或-号，求出能不能使算出的结果被K整除。可以则打印“Divisible”，否则打印“Not divisible”

 

(1 <= N <= 10000, 2 <= K <= 100)

下面是一个例子：

 

有4个数，分别是17 5 -21 15

 

17 + 5 + -21 + 15 = 16

17 + 5 + -21 - 15 = -14

17 + 5 - -21 + 15 = 58

17 + 5 - -21 - 15 = 28

17 - 5 + -21 + 15 = 6

17 - 5 + -21 - 15 = -24

17 - 5 - -21 + 15 = 48

17 - 5 - -21 - 15 = 18

 

有8种添法，其中第二种求出的-14能被7整除。

 

【输入文件】

The first line of the input contains two integers, N and K (1 <= N <= 10000, 2 <= K <= 100) separated by a space.

The second line contains a sequence of N integers separated by spaces. Each integer is not greater than 10000 by it's absolute value.

注意第一个数是测试数据的组数，多组测试数据一起测。。

【输出文件】

Write to the output file the word "Divisible" if given sequence of integers is divisible by K or "Not divisible" if it's not.

The first line of a multiple input is an integer N, then a blank line followed by N input blocks. Each input block is in the format indicated in the problem description. There is a blank line between input blocks.

The output format consists of N output blocks. There is a blank line between output blocks.

注意：输出每组结果之间有空格，最后一行无空格，格式不对不能AC，我就是因为格式不对调了一上午。。。。

【输入样例】

2

 

4 7

17 5 -21 15

 

4 5

17 5 -21 15

【输出样例】

Divisible

 

Not divisible

【问题分析】

看到题目第一个反映就是枚举中间添的运算符，算出值在MOD K如果有一个值MOD K=0则输出“Divisible”。

时间复杂度是O（2N-1）。

但是题目给出的数据量很大，这样做效率太低了。

因为题目涉及MOD运算，要想简化问题就需要知道一些基本的MOD运算性质：

A*B mod C=(A mod C*B mod C) mod C

(A+B) mod C=(A mod C+B mod C) mod C

有了这个性质，我们就可以把累加后求余转化成求余后累加（我们把减法看作加负数以后分析只说加法）再求余。这样我们的读入数据就控制在了1-K到K-1的范围内了。

我们要判断的就是

所有结果的累加和 MOD K 是否为0。简记为:

（A+B）mod K=0 or (A+B) mod K<>0

如果我们按数的个数划分阶段，前N-1个数的运算结果 MOD K看做A，第N个数看作B就OK了。

于是我们想到了这样的状态：opt[i,j]表示前i个数是否可以得到余数为J的结果。

那么状态转移方程就是

opt[i,(j-a[i] mod k )mod k]=opt[i-1,j]            (opt[i-1,j]=true);

opt[i,(j+a[i] mod k) mod k]=opt[i-1,j]           (opt[i-1,j]=true);

如果opt[n,0]=true就输出‘Divisible’

注意上面

【源代码】

program P2042;

const

 maxk=110;

 maxn=10010;

var

 a:array[0..maxn] of longint;

 opt:array[1..2,-maxk..maxk] of boolean;

 n,k,tim,ii:longint;

 vis:array[0..maxn] of boolean;

procedure init;

 var

  i:longint;

 begin

  read(n,k);

  for i:=1 to n do

   read(a[i]);

 end;

procedure main;

 var

  i,j,p1,p2,p3:longint;

 begin

  fillchar(opt,sizeof(opt),false);

  fillchar(vis,sizeof(vis),false);

  for i:=1 to n do

   if a[i] mod k=0 then vis[i]:=true;

  for i:=1 to n do

   a[i]:=a[i] mod k;

  opt[1,a[1]]:=true;

  p1:=1;

  p2:=2;

  for i:=2 to n do

   if not vis[i] then

    begin

     fillchar(opt[p2],sizeof(opt[p2]),false);

     for j:=1-k to k-1 do

      if opt[p1,j] then

       begin

        opt[p2,(j-a[i]) mod k]:=true;

        opt[p2,(j+a[i]) mod k]:=true;

       end;

     p3:=p1;

     p1:=p2;

     p2:=p3;

    end;

 if opt[p1,0] then writeln('Divisible')

 else writeln('Not divisible');

 end;

begin

 read(tim);

 for ii:=1 to tim do

  begin

   if ii>1 then

   writeln;

   init;

   main;

  end;

end.

### 动态规划入门28
分类：算法与数据结构 

3.多维状态和动态规划的优化

    一般多维动态规划的时，空间复杂度较高，所以我们要想办法将其优化，我就把多维动态规划和动态规划的优化放到一起了……

    多维动态规划以三，四维最为常见，在多的也没有太大的研究价值，其实多维动态规划大多也就是上面的一维，和二维的加一些条件，或是在多进程动态规划中要用到。当然除了这些特点外，状态的表示也有一些共性。

三维：状态opt[i,j,k]一般可表示下面的含义：

（1）二维状态的基础上加了某个条件，或其中一维变成两个。

      比如opt[L,i]表示起点为I，长度为L的序列的最优值。opt[L,i,j]就可表示起点是i和起点是j，长度是L的两个序列的最优值。

（2）I，J，K组合表示一个正方形（（i,j）点为一角，边长为K）。

    （3）I，J，K组合表示一个等边三角形（（i,j）点为一角，边长为K）。

四维：除了二维和三维加条件外，还可以用i,j,k,t组合来描述一个矩形，

      （i,j）点和（k,t）点是两个对顶点。

四维以上的一般都是前几维加了条件了，这里就不多说了。

动态规划的优化：

动态规划的优化往往需要较强的数学功底。

常见空间优化：

滚动数组，滚动数组在前面也提到过，其实很简单，如果一个状态的决策的步长为N就只保留以求出的最后N（一般N=1）个阶段的状态，因为当前状态只和后N个阶段中的状态有关，再以前的已经利用过了，没用了就可以替换掉了。具体实现是最好只让下标滚动（这样更省时间）。

         X：=K1，K1：=K2，K2；=K3，K3：=X这样就实现了一个N=3的下标的滚动，在滚动完如果状态是涉及累加，累乘类的操作要注意将当前要求的状态初始化。

常见时间优化：利用一些数据结构（堆，并查集，HASH）降低查找复杂度。

    时间空间双重优化：改变状态的表示法，降低状态维数。

具体的多维动态规划和动态规划的优化，我们从题目里体会吧！

3.1矩阵问题

   先看一道题

例题27

 

 



盖房子

来源：VIJOS P1057

【问题描述】

永恒の灵魂最近得到了面积为n*m的一大块土地（高兴ING^_^），他想在这块土地上建造一所房子，这个房子必须是正方形的。
但是，这块土地并非十全十美，上面有很多不平坦的地方（也可以叫瑕疵）。这些瑕疵十分恶心，以至于根本不能在上面盖一砖一瓦。
    他希望找到一块最大的正方形无瑕疵土地来盖房子。
    不过，这并不是什么难题，永恒の灵魂在10分钟内就轻松解决了这个问题。现在，您也来试试吧。

【输入文件】

输入文件第一行为两个整数n,m（1<=n,m<=1000），接下来n行，每行m个数字，用空格隔开。0表示该块土地有瑕疵，1表示该块土地完好。

【输出文件】

一个整数，最大正方形的边长。

【输入样例】

4 4

0 1 1 1

1 1 1 0

0 1 1 0

1 1 0 1

【输出样例】

2

【问题分析】

    题目中说要求一个最大的符合条件的正方形，所以就想到判断所有的正方形是否合法。

这个题目直观的状态表示法是opt[i,j,k]基类型是boolean，判断以（i,j）点为左上角（其实任意一个角都可以，依据个人习惯）,长度为K的正方形是否合理，再找到一个K值最大的合法状态就可以了（用true表示合理，false表示不合理）。其实这就是递推，（决策唯一）。

递推式：

opt[i,j,k]=opt[i+1,j+1,k-1] and opt[i+1,j,k-1] and opt[i,j+1,k-1] and (a[i,j]=1)

时间复杂度：

状态数O（N3）*转移代价O（1）=总复杂度O（N3）

空间复杂度：

O（N3）

由于空间复杂度和时间复杂度都太高，不能AC，我们就的再想想怎么优化？

显然何以用滚动数组优化空间，但是时间复杂度仍然是O（N3）。这就需要我们找另外一种简单的状态表示法来解了。

仔细分析这个题目，其实我们没必要知道正方形的所有长度，只要知道以一个点为左上角的正方形的最大合理长度就可以了。

如果这个左上角是0那么它的最大合理长度自然就是0（不可能合理）。

如果这个左上角是1呢？

回顾上面的递推式，我们考虑的是以它的右面，下面，右下这个三个方向的正方形是否合理，所以我们还是要考虑这三个方向。具体怎么考虑呢？

如果这三个方向合理的最大边长中一个最小的是X，那么它的最大合理边长就是X+1。为什么呢？

看个例子：

0 1 1 1 1 1

1 1 1 1 1 1

0 1 0 1 1 0

1 1 0 1 1 1

 

上例中红色的正方形，以（1,3）点为左上角，以（1，4），（2，3），（2，4）这三个点的最大合理边长分别是2，1，2。其中最小的是以（2，3）为左上角的正方形，最大合理边长是1。因为三个方向的最大合理边长大于等于1，所以三个方向上边长为1的正方形是合理的，即上面低推式中:

opt[1,3,2]=opt[1,4,1] and opt[2,3,1] and opt[2,4,1] and (a[1,3]=1) = true 成立

这样就把一个低推判定性问题转化成最优化问题从而节省空间和时间。

具体实现：

设计一个状态opt[i,j]表示以（i,j）为左上角的正方形的最大合理边长。

状态转移方程：

           min{opt[i+1,j],opt[i,j+1],opt[i+1,j+1]}+1       (a[i,j]=1)

opt[i,j]=

0                                                                                                                                                                                                                      (a[i,j]=0)

时间复杂度：状态数O（N2）*转移代价O（1）=总代价O（N2）

空间复杂度：O（N2）

【源代码】

program P1057;

const

 maxn=1010;

var

 opt,a:array[0..maxn,0..maxn] of longint;

 n,m,ans:longint;

procedure init;

 var

  i,j:longint;

 begin

  read(n,m);

  for i:=1 to n do

   for j:=1 to m do

    read(a[i,j]);

 end;

procedure main;

 var

  i,j:longint;

 begin

  fillchar(opt,sizeof(opt),0);

  for i:=n downto 1 do

   for j:=m downto 1 do

    if a[i,j]<>0 then

     begin

      opt[i,j]:=opt[i+1,j];

      if opt[i,j+1]<opt[i,j] then

       opt[i,j]:=opt[i,j+1];

      if opt[i+1,j+1]<opt[i,j] then

       opt[i,j]:=opt[i+1,j+1];

      inc(opt[i,j]);

     end;

  ans:=0;

  for i:=1 to n do

   for j:=1 to m do

    if opt[i,j]>ans then ans:=opt[i,j];

  writeln(ans);

 end;

begin

 init;

 main;

end.                   

### 动态规划入门29
分类：算法与数据结构 

3.2多进程动态规划

    从字面上就可以看出，所谓多进程就是在原文题的基础上要求将这个问题重复多次的总和最大。

具体怎么做看个例题吧。

 

 例题28

 



方格取数

(fgqs.pas/c/cpp)

来源：NOIP2000(提高组)

【问题描述】

设有N*N的方格图(N<=10,我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。如下图所示（见样例）：

某人从图的左上角的A 点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。

【输入文件】

 输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。

【输出文件】

    只需输出一个整数，表示2条路径上取得的最大的和。

【输入样例】

8

2  3  13

2  6  6

3  5  7

4  4  14

5  2  21

5  6  4

6  3  15

7  2  14

0  0  0

【输出样例】

67

【问题分析】

这是一道很经典的多进程动态规划题，如果只取一次，它的模型就是我们前面讲的街道问题了，很简单就可以实现。现在要求取两次，怎么办呢？

一个自然的想法是：将前面的取过的数全赋成0，然后在取一次，感觉挺对的，样例也过了。

但这样做是错的，第一次取的显然是最大值，但第二次取的未必次大，所以也许两条非最大的路，也许比一条最大一条小一点的路更优。

看个例子：

0 0 2 0 3 0                      0 0 2 0 3 0

0 0 2 0 0 0                      0 0 2 0 0 0

0 0 2 0 2 0                      0 0 2 0 2 0

0 0 0 0 2 0                      0 0 0 0 2 0

0 0 0 0 2 0                      0 0 0 0 2 0

0 0 2 0 2 0                      0 0 2 0 2 0

图1                                图2

如上图，图1是按找上诉思路求得的解。图中红色路线是第一求得的最大值，显然图1红色和紫色两条路径不如图2蓝色和绿色两条路径大。

既然这样做不行，我们还得回到动态规划的本质来看代问题，我们在想想这个问题的状态，对于走一次，走到矩阵的任意一个位置就是一个状态，而要是走两次，显然走到矩阵的某个位置只是一个状态的一部分，不能完整的描述整个状态。那另一部分显然就是第二次走到的位置了。如果我们把这两部分合起来就是一个完整的状态了。

于是，设计一个状态opt[i1,j1,i2,j2]表示两条路分别走到（i1,j1）点和（i2,j2）点时取到的最大值。显然决策有4中（乘法原理一个点两种*另一个点的两中）

即（上，上）（上，左）（左，上）（左，左）上和左表示从哪个方向走到该点，当然要注意走到同行，同列，同点时的情况（因为要求路径不重复）。

状态转移方程：

         max(opt[i1-1,j1,i2-1,j2],opt[i1,j1-1,i2-1,j2])+a[i1,j1]+a[i2,j2]  (1<=i1=i2<=n,1<=j1<=j2<=n)

         max(opt[i1-1,j1,i2,j2-1],opt[i1,j1-1,i2,j2-1])

                                      (1<=j1=j2<=n,1<=i1<=i2<=n)

opt[i,j]=  max(opt[i1-1,j1,i2-1,j2],opt[i1-1,j1,i2,j2-1],opt[i1,j1-1,i2-1,j2],

opt[i1,j1-1,i2,j2-2])+a[i1,j1]+a[i2,j2]  (1<=i1,j1<=i2,j2<=n)

        max(opt[i1-1,j1,i2-1,j2],opt[i1-1,j1,i2,j2-1],opt[i1,j1-1,i2-1,j2],

opt[i1,j1-1,i2,j2-2])+a[i1,j1]   (1<=i1=i2<=n,1<=j1=j2<=n)

 

时间复杂度：状态数O（N4）*转移代价O（1）=总复杂度O（N4）

空间复杂度：O（N4）

由于数据很小所以这样做虽然时间和空间复杂度都很高但还是可以AC的。

【源代码1】

program fgqs;

const

 fin='fgqs.in';

 fout='fgqs.out';

 maxn=11;

var

 a:array[0..maxn,0..maxn] of longint;

 opt:array[0..maxn,0..maxn,0..maxn,0..maxn] of longint;

 n:longint;

procedure init;

 var

  i,j,w:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(n);

  repeat

   readln(i,j,w);

   a[i,j]:=w;

  until i=0;

  close(input);

 end;

function max(x,y:longint):longint;

 begin

  max:=y;

  if x>y then max:=x;

 end;

procedure main;

 var

  i1,i2,j1,j2:longint;

 begin

  for i1:=1 to n do

   for j1:=1 to n do

    for i2:=i1 to n do

     for j2:=1 to j1 do

      if (i1=i2) and (j1=j2) then

       opt[i1,j1,i2,j2]:=opt[i1-1,j1,i2,j2-1]+a[i1,j1]

      else if (i1=i2-1) and (j1=j2) then

       opt[i1,j1,i2,j2]:=max(opt[i1-1,j1,i2,j2-1],opt[i1,j1-1,i2,j2-1])

+a[i1,j1]+a[i2,j2]

      else if (i1=i2) and (j1=j2+1) then

       opt[i1,j1,i2,j2]:=max(opt[i1-1,j1,i2,j2-1],opt[i1-1,j1,i2-1,j2])

+a[i1,j1]+a[i2,j2]

      else begin

            opt[i1,j1,i2,j2]:=max(opt[i1-1,j1,i2,j2-1],opt[i1-1,j1,i2-1,j2]);

            opt[i1,j1,i2,j2]:=max(opt[i1,j1,i2,j2],opt[i1,j1-1,i2,j2-1]);

            opt[i1,j1,i2,j2]:=max(opt[i1,j1,i2,j2],opt[i1,j1-1,i2-1,j2]);

            inc(opt[i1,j1,i2,j2],a[i1,j1]+a[i2,j2]);

           end;

 end;

procedure print;

 begin

  writeln(opt[n,n,n,n]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.       

   如果这个题的数据范围在大点就得优化了，怎么优化这个程序呢？

   上面说过对于时间空间都大的时候，首先想到的就是寻找特点，改变状态的表示法，减少状态的维数。

   仔细分析我们发现，处于同行，同列的状态，等价于另外一个点在对角线上的状态。而这条对角线正是此题的阶段。因为在状态转移的时候后面的哪个点总是从固定的一个方向转移来的。也就是说我们只要对角先上的状态就可以省掉那些同行同列的状态了。

做过N皇的同学一定知道怎么表示右上到左下的这几条对角线，不知道的同学也没关系,对于一个点（i,j）他对角右上角的点就是（i-1，j+1）所以可以看出这些点的和是定值，且值从2到N*2。

这样用三个变量就可以表示这两个点了，于是设计状态opt[k,i1,i2]表示处于阶段K时走到i1,i2的两条路径所取得的数的最大和。

用上面的思维不难想出动态转移方程：

            max(opt[k-1,i1-1,i2-1],opt[k-1,i1-1,i2],opt[k-1,i1,i2-1],

opt[k-1,i1,i2])+a[i1,k-i1]+a[i2,k-i2]   

(1<=i1,i2<=n,2<=k<=n*2,i1<>i2)

otp[k,i1,i2]=

opt[k-1,i1-1,i2]+a[i1,k-i1]

(1<=i1,i2<=n,2<=k<=n*2,i1=i2)

 

【源代码2】

program fgqs;

const

 fin='fgqs.in';

 fout='fgqs.out';

 maxn=11;

var

 a:array[0..maxn,0..maxn] of longint;

 opt:array[0..maxn*2,0..maxn,0..maxn] of longint;

 n:longint;

procedure init;

 var

  i,j,w:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(n);

  repeat

   readln(i,j,w);

   a[i,j]:=w;

  until i=0;

  close(input);

 end;

function max(x,y:longint):longint;

 begin

  max:=y;

  if x>y then max:=x;

 end;

procedure main;

 var

  k,i1,i2,j1,j2,mid:longint;

 begin

  for k:=2 to n*2 do

   begin

    for i1:=1 to n do

     if (k-i1>0) and (k-i1<=n) then

      for i2:=1 to n do

       if (k-i2>0) and (k-i2<=n) then

        begin

         if i1=i2 then

          opt[k,i1,i2]:=opt[k-1,i1-1,i2]+a[i1,k-i1]

         else begin

               opt[k,i1,i2]:=max(opt[k-1,i1,i2],opt[k-1,i1,i2-1]);

               opt[k,i1,i2]:=max(opt[k,i1,i2],opt[k-1,i1-1,i2]);

               opt[k,i1,i2]:=max(opt[k,i1,i2],opt[k-1,i1-1,i2-1]);

               inc(opt[k,i1,i2],a[i1,k-i1]+a[i2,k-i2]);

              end;

        end;

   end;

 end;

procedure print;

 begin

  writeln(opt[n*2,n,n]);

  close(output);

 end;

begin

 init;

 main;

 print;

end.                          

注：如果取多次，和取两次道理一样，只不过有多一次，状态就多加一维，如果数据范围很大，时间空间复杂度太高时可以用网络流解这个问题，只是本人才疏学浅不能和大家分享了。

### 动态规划入门30
分类：算法与数据结构 

4.树型动态规划

   由于树型动态规划比较特殊，要借助树这种数据结构，所以很多地方都把它独立看做一类，我也不例外。

   一般树型动态规划都是建立在二叉树上的，对于普通的树和森林要把它们转化成二叉树，以前认为数据结构中将的转化没什么用处，现在终于用到了。

   树型动态规划是动态规划类中最好分析的，因为树本来就是一个低归的结构，阶段，状态，决策都很明显，子问题就是子树的最优值，也很明显。

   较其他类型的动态规划不同的是，求解树型动态规划的第一步一般要先建立数据结构，考虑问题的数据结构是二叉树呢？还是多叉树，还是森林……

   其他类型的动态规划一般都是用逆向递推实现，而树型动态规划一般要正向求解，为了保证时间效率要加记忆化（即长说的记忆化搜索）。

树型动态规划的三要素：

阶段：树的层数

状态：树中的结点

决策：某个子数的最优，或所有子树的最优和，或某几个子树的最优

    通过上面的决策，发现如果是一棵多叉树，针对求某几个（>=1）子树的最优解，决策会很多。以至于我们没发写出准确的状态转移方程。这就是我们为什么要把多叉数转化成二叉数的原因。（当然，如果问题是求所有子树的和，就没必要转化了，如URAL P1039 没有上司的舞会）。

    如果把多叉树或森林转化成二叉树要注意，左儿子和根结点是父子关系，而右儿子在原问题中和跟结点是兄弟关系。（这个数据结构掌握扎实的应该能明白，不理解的就去看数据结构方面的知识）。

用邻接矩阵存多叉树，转化成二叉树的部分代码（可能有语法错误）

G: 存图，F[i] 表示第i个结点的儿子应该插入的位置

W：结点的值 BT：二叉树

Procedure creat_tree(T:tree);

 Var

   i:longint;

Begin

  for i:=1 to n do

   Begin

    for j:=1 to n do

     If g[i,j] then

      Begin

       If  F[i]=0 then

        BT[i].L:=j

       Else  BT[F[i]].r:=j;

       F[i]:=j;

      End;

   End;

End;

  下面同过例题看一下树型动态规划的具体实现：

 

 

例题29

加分二叉树

(binary.pas/c/cpp)

来源：NOIP2003（提高组）

【问题描述】

    设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：

    subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数

    若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空

子树。

    试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；

    （1）tree的最高加分

    （2）tree的前序遍历

【输入格式】

    第1行：一个整数n（n＜30），为节点个数。

    第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。

【输出格式】

    第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。

    第2行：n个用空格隔开的整数，为该树的前序遍历。

【输入样例】

    5

    5 7 1 2 10

【输出样例】

    145

    3 1 2 4 5

【问题分析】

根据题目描述就可以看出是典型的树型动态规划，而且题目中已经给出了加分的求法：

    subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数

这估计是最简单的题目了。

但是有一点需要注意：我们应该怎么建树？

其实这个题不用建树，这就需要我们对数据结构掌握的很扎实。

题目中说这个树的中序遍历是1，2，3……N，我们要求的是树的先序，这样马上就想到怎样用中序和先序确定一棵树。

枚举树根i那么1，2……i-1就是它的左子树中的结点，i+1……N就是它右子树中的结点。这样一颗树按这样的低归定义就构造出来了，（当然我们只要这个过程并不需要存储这棵树）。在构造过程中顺便求出加分来，在一个序列里不同的元素做根显然加分不同，我们只要记录一个最大的就可以了。

具体实现方法：

设计状态opt[L,r]表示以L为起点，以r为终点的结点所组成的树的最高加分，阶段就是树的层数。决策就是在这些结点中找一个结点做根使树的加分最大，状态转移方程：

            1                             (L>r)

opt[L,r] =  a[L]                           (L=r)

          max{opt[L,i-1]*opt[i+1,r]+a[i]}     (L<r,L<=i<=r)

在保存最优解的过程用path[i,j]记录以i为起点，以j为终点的中序结点中的根就可以了。

由于树型动态规划的阶段不明显所以一般用记忆化搜索好实现。

时间复杂度：状态数O(N2)*转移代价O(N)=O（N3）

【源代码】

program binary;

const

 fin='binary.in';

 fout='binary.out';

 maxn=100;

var

 a:array[0..maxn] of longint;

 path,opt:array[0..maxn,0..maxn] of longint;

 n:longint;

procedure init;

 var

  i:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  read(n);

  for i:=1 to n do

   read(a[i]);

  close(input);

  fillchar(opt,sizeof(opt),0);

 end;

function TreeDp(L,r:longint):longint;

 var

  i,x:longint;

 begin

  if opt[L,r]=0 then

   begin

    if L>r then

     begin

      opt[L,r]:=1;

      path[L,r]:=0;

     end

    else if L=r then

     begin

      opt[L,r]:=a[L];

      path[L,r]:=L;

     end

    else begin

          for i:=L to r do

           begin

            x:=TreeDp(L,i-1)*TreeDp(i+1,r)+a[i];

            if x>opt[L,r] then

             begin

              opt[L,r]:=x;

              path[L,r]:=i;

             end;

           end;

         end;

   end;

  TreeDp:=opt[L,r];

 end;

procedure print(L,r:longint);

 begin

  if path[L,r]>0 then

   begin

    write(path[L,r],' ');

    print(L,path[L,r]-1);

    print(path[L,r]+1,r);

   end;

 end;

begin

 init;

 writeln(TreeDp(1,n));

 print(1,n);

 close(output);

end.          
### 动态规划入门31
 分类：算法与数据结构 

 例题30

A Binary Apple Tree 苹果二叉树

来源：URAL P1018

【问题描述】

    Let's imagine how apple tree looks in binary computer world. You're right, it looks just like a binary tree, i.e. any biparous branch splits up to exactly two new branches. We will enumerate by natural numbers the root of binary apple tree, points of branching and the ends of twigs. This way we may distinguish different branches by their ending points. We will assume that root of tree always is numbered by 1 and all numbers used for enumerating are numbered in range from 1 to N, where N is the total number of all enumerated points. For instance in the picture below N is equal to 5. Here is an example of an enumerated tree with four branches:
    设想苹果树很象二叉树，每一枝都是生出两个分支。我们用自然数来数这些枝和根那么必须区分不同的枝（结点），假定树根编号都是定为1，并且所用的自然数为1到N。N为所有根和枝的总数。例如下图的N为5，它是有4条枝的树。

   2   5 
    \ /  
     3   4 
      \ / 
       1 
As you may know it's not convenient to pick an apples from a tree when there are too much of branches. That's why some of them should be removed from a tree. But you are interested in removing branches in the way of minimal loss of apples. So your are given amounts of apples on a branches and amount of branches that should be preserved. Your task is to determine how many apples can remain on a tree after removing of excessive branches.
    当一棵树太多枝条时，采摘苹果是不方便的，这就是为什么有些枝要剪掉的原因。现在我们关心的是，剪枝时，如何令到损失的苹果最少。给定苹果树上每条枝的苹果数目，及必须保留的树枝的数目。你的任务是计算剪枝后，能保留多少苹果。

【输入文件】

    First line of input contains two numbers: N and Q (1 <= Q <= N, 1 < N <= 100). N denotes the number of enumerated points in a tree. Q denotes amount of branches that should be preserved. Next N-1 lines contains descriptions of branches. Each description consists of a three integer numbers divided by spaces. The first two of them define branch by it's ending points. The third number defines the number of apples on this branch. You may assume that no branch contains more than 30000 apples.
    首行为N，Q (1 <= Q <= N, 1 < N <= 100), N为一棵树上的根和枝的编号总数，Q为要保留的树枝的数目。以下N-1行为每条树枝的描述，用3个空格隔开的整数表示，前2个数为树枝两端的编号,第三个数为该枝上的苹果数。假设每条枝上的苹果数不超过3000个。

【输出文件】

    Output file should contain the only number ?amount of apples that can be preserved. And don't forget to preserve tree's root ;-)
     输出能保留的苹果数。（剪枝时，千万不要连根拔起哦）

【输入样例】

5 2 
1 3 1 
1 4 10 
2 3 20 
3 5 20 
【输出样例】

21

【提交链接】

http://acm.timus.ru/problem.aspx?space=1&num=1018

【问题分析】

和上一道题一样，题目描述就很明确的说是关于树的题目，在加上是求最优值，和上一道题不同的是，这个题目边有值，并非点有值，还有一个不同点就是这个题需要建树。

建树是要注意，给每个结点增加一个域：SUM用来存以它为根的树中的边的数目。

其实树型动态规划是最好分析的，因为树这种数据结构本来就符合递归定义，这样的话子问题很好找，显然这个问题的子问题就是一棵树要保留M个枝分三种情况：

剪掉左子树：让右子树保留M-1个枝可保留最多的苹果数+连接右子树的枝上的苹果数

剪掉右子树：让左子树保留M-1个枝可保留最多的苹果数+连接左子树的枝上的苹果数

都不剪掉：  让左子树保留i个枝，让右子树保留M-2-i个枝可保留最多的苹果数+连接右子树的枝上的苹果数+连接左子树的枝上的苹果数

显然边界条件就是如果要保留的枝子数比当前的子树的枝多，或着一个树要保留0个枝子，则结果就是0。

应为一颗树中根接点是对子树的完美总结，所以满足最优化原理。

没次求解只和子树有关所以也满足无后效性，可见用动态规划做是正确的。

设计一个状态opt[num,i]表示要让结点编号为i的树保留num个枝可得到的最优解。

状态转移方程：

opt[num,i]=max{opt[num-1,BT[i].L]+T[i,BT[i].L],opt[num-1,BT[i].r]+T[i,BT[i].r],opt[k,BT[i].L]+opt[num-2-k,BT[i].r]+T[i,BT[i].L]+T[i,BT[i].r]}  

(0<=k<=n-2,BT:树，T：读入时记录的枝上的苹果数)；

时间复杂度：状态数O(NM)*转移代价O(M)=O（NM2）

【源代码】

program P1018;

const

 fin='P1018.in';

 fout='P1018.out';

 maxn=110;

type

 treetype=record

           l,r,sum:longint;

          end;

var

 T,opt:array[0..maxn,0..maxn] of longint;

 BT:array[0..maxn] of treetype;

 vis:array[0..maxn] of boolean;

 n,m,p:longint;

procedure init;

 var

  i,j,k,w:longint;

 begin

  assign(input,fin);

  reset(input);

  assign(output,fout);

  rewrite(output);

  fillchar(T,sizeof(T),0);

  read(n,m);

  for k:=1 to n-1 do

   begin

    read(i,j,w);

    T[i,j]:=w;

    T[j,i]:=w;

   end;

  close(input);

  fillchar(vis,sizeof(vis),false);

 end;

Procedure creat_tree(i:longint);

 var

  j:longint;

 begin

  vis[i]:=true;

  for j:=1 to n do

   if (T[i,j]>0) and (not vis[j]) then

    begin

     creat_tree(j);

     BT[i].L:=Bt[i].r;

     Bt[i].r:=j;

     inc(Bt[i].sum,BT[j].sum+1);

    end;

 end;

Function max(x,y:longint):longint;

 begin

  max:=y;

  if x>y then max:=x;

 end;

Function F(num,i:longint):longint;

 var

  k:longint;

 begin

  if opt[num,i]<0 then

   begin

    if (num>BT[i].sum) or (num=0) then opt[num,i]:=0

    else begin

          opt[num,i]:=F(num-1,BT[i].L)+T[i,BT[i].L];

          opt[num,i]:=max(opt[num,i],F(num-1,BT[i].r)+T[i,BT[i].r]);

          for k:=0 to num-2 do

           opt[num,i]:=max(opt[num,i],F(k,BT[i].L)+F(num-2-k,BT[i].r)

+T[i,BT[i].L]+T[i,BT[i].r]);

         end;

   end;

  F:=opt[num,i];

 end;

begin

 init;

 creat_tree(1);

 fillchar(opt,sizeof(opt),200);

 writeln(F(m,1));

 close(output);

end.

### 动态规划入门32
分类：算法与数据结构 

例题31 

选课

来源：VIJOS P1180

【问题描述】

学校实行学分制。每门的必修课都有固定的学分，同时还必须获得相应的选修课程学分。学校开设了N（N<300）门的选修课程，每个学生可选课程的数量M是给定的。学生选修了这M门课并考核通过就能获得相应的学分。
　　在选修课程中，有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其它的一些课程的基础上才能选修。例如《Frontpage》必须在选修了《Windows操作基础》之后才能选修。我们称《Windows操作基础》是《Frontpage》的先修课。每门课的直接先修课最多只有一门。两门课也可能存在相同的先修课。每门课都有一个课号，依次为1，2，3，…。例如:
   表中1是2的先修课，2是3、4的先修课。如果要选3，那么1和2都一定已被选修过。　　你的任务是为自己确定一个选课方案，使得你能得到的学分最多，并且必须满足先修课优先的原则。假定课程之间不存在时间上的冲突。

【输入文件】

输入文件的第一行包括两个整数N、M（中间用一个空格隔开）其中1≤N≤300,1≤M≤N。

以下N行每行代表一门课。课号依次为1，2，…，N。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为0），第二个数为这门课的学分。学分是不超过10的正整数。

【输出文件】

  输出文件只有一个数,实际所选课程的学分总数。

【输入样例】

7 4

2 2

0 1

0 4

2 1

7 1

7 6

2 2

【输出样例】

13

【问题分析】

事先说明题目描述有个漏洞，应该是二个以上的课程可能有同一个先修课。

换句话讲，一个课程可能是多个课程的先修课，可是一个课最多只有一个先修课。这样的描述好象和我们以前学过的一种数据结构的描述一样。

你想对了，就是树。

因为是建立在树这种数据结构上的最优化问题，我们自然想到了树型动态规划。想到树型动态规划，那么第一步就是想这课树是否是二叉树，如果不是，是否需要转化呢？

显然这个问题不是二叉树，有应为问题是在多个课程中选M个，也就是说是树中一棵或多棵子树的最优解，这样问题就需要转化成二叉树了。注意题目中说一个课程没有先修课是0，也就是说这课树的根是0。

把数据结构确定了以后就要想动态规划的三要素了。

树型动态规划阶段的具有共性：树的层数，

状态是结点，但是只描述结点显然不够，需要在加一个参数。于是我们想到设计一个状态opt[i,j]表示以i为跟的树，选j个课程可获得的最优解。

因为树是以0为根的而0又必须要选所以问题的解不是opt[0,m]而是opt[0,m+1]。

决策是什么呢？

对于二叉树我在设计决策时习惯分类讨论这样结构清晰。

<1>这棵树只有左子树：

要选左子树中的课程，那么根结点一定要选，所以决策就是在左子树中选j-1个课程，在加上选根结点可获得的分数。

<2>这棵树只有右子树：

    因为右子树和根在原问题中是兄弟关系，所以选右子树中的课程未必要选根，这样决策就有两条：（1）在右子树中选j个的最优值。（2）在右子树中选j-1个的最优值加上选根结点可获得的分数。

 

<3>都有：

    这种情况的决策很容易想到，从左子树中选k-1个，从右子树中选j-k个的最优值加上根结点可获得的分数。

    但要注意，当K=1也就是左子树选0个时，根结点可以不选，右子树可以选j个而不是j-1个；当然根结点也可以选，选了根结点右子树就得选j-1个了。

针对不同情况写出状态转移方程：

max(opt[t[i].L,j-1]+t[i].data)                   （只有左子树）

opt[i,j] = max(opt[t[i].r,j-1]+t[i].data, opt[t[i].r,j])           （只有右子树）

        max(opt[t[i].L,k-1]+opt[t[i].r,j-k]+t[i].data,opt[t[i].r,j])（都有） 

(1<=k<=j)

时间复杂度：

    状态数O（NM）*转移代价O（M）=O（NM2）

注：（1）实际转移代价比理论值小的多。

【源代码】

program P1180;

const

maxn=400;

type

 treetype=record

           data,L,r:longint;

          end;

var

 T:array[0..maxn] of treetype;

 opt:array[0..maxn,0..maxn] of longint;

 n,m,ans:longint;

 F:array[0..maxn] of longint;

procedure init;

 var

  i,x,y:longint;

 begin

  read(n,m);

  fillchar(f,sizeof(f),0);

  for i:=0 to n do

   begin

    T[i].L:=-1;

    T[i].r:=-1;

   end;

  for i:=1 to n do

   begin

    read(x,y);                         {边读入边将多叉树转化成二叉树}

    T[i].data:=y;

    if F[x]=0 then T[x].L:=i

    else T[F[x]].r:=i;

    F[x]:=i;

   end;

  fillchar(opt,sizeof(opt),200);

  for i:=0 to n do

   opt[i,0]:=0;

 end;

function max(x,y:longint):longint;

 begin

  max:=y;

  if x>y then max:=x;

 end;

function TreeDp(i,j:longint):longint;

 var

  k:longint;

 begin

  if opt[i,j]<0 then

   begin

    if (T[i].L<0) and (T[i].r<0) then

     begin

      if j<>1 then opt[i,j]:=0

      else opt[i,j]:=T[i].data;

     end

    else if (T[i].L>=0) and (T[i].r<0) then

     opt[i,j]:=max(opt[i,j],TreeDp(T[i].L,j-1)+T[i].data)

    else if (T[i].L<0) and (T[i].r>=0) then

     begin

      opt[i,j]:=max(opt[i,j],TreeDp(T[i].r,j));

      opt[i,j]:=max(opt[i,j],TreeDp(T[i].r,j-1)+T[i].data);

     end

    else begin

          opt[i,j]:=max(opt[i,j],TreeDp(T[i].r,j));

          for k:=1 to j do

           opt[i,j]:=max(opt[i,j],TreeDp(T[i].L,k-1)+

TreeDp(T[i].r,j-k)+T[i].data);

         end;

   end;

  TreeDp:=opt[i,j];

 end;

begin

 init;

 writeln(TreeDp(0,m+1));

end.


### 状态转移方程 公式

-我们将人生划为诡异的阶段·我们把这个世界表为丰富的状态

1.	资源问题1
			-----机器分配问题
         		F[I,j]:=max(f[i-1,k]+w[i,j-k])

		2.	资源问题2
			------01背包问题
  			F[I,j]:=max(f[i-1,j-v[i]]+w[i],f[i-1,j]); 

		3.	线性动态规划1
			-----朴素最长非降子序列
  			F[i]:=max{f[j]+1}

		4.	剖分问题1
			-----石子合并
			F[i,j]:=min(f[i,k]+f[k+1,j]+sum[i,j]);

		5.	剖分问题2
			-----多边形剖分
			F[I,j]:=min(f[i,k]+f[k,j]+a[k]*a[j]*a[i]);

		6.	剖分问题3
			------乘积最大
			f[i,j]:=max(f[k,j-1]*mult[k,i]);

		7.	资源问题3
		  	-----系统可靠性(完全背包)
			F[i,j]:=max{f[i-1,j-c[i]*k]*P[I,x]}

		8.	贪心的动态规划1
			-----快餐问题
			  F[i,j,k]:=max{f[i-1,j',k']+(T[i]-(j-j')*p1-(k-k')*p2) div p3}   

		9.	贪心的动态规划2
			-----过河 f[i]=min{{f(i-k)} (not stone[i])
               		     		  {f(i-k)}+1} (stone[i]);  +贪心压缩状态

		10.	剖分问题4
-----多边形-讨论的动态规划
			F[i,j]:=max{正正 f[I,k]*f[k+1,j];
       				    负负 g[I,k]*f[k+1,j];
         			    正负 g[I,k]*f[k+1,j];
          			    负正 f[I,k]*g[k+1,j];}  g为min

		11.	树型动态规划1
			-----加分二叉树 (从两侧到根结点模型)
        		F[I,j]:=max{f[I,k-1]*f[k+1,j]+c[k]}

		12.	树型动态规划2
			-----选课 (多叉树转二叉树,自顶向下模型)
       			 F[I,j]表示以i为根节点选j门功课得到的最大学分
        		 f[i,j]:=max{f[t[i].l,k]+f[t[i].r,j-k-1]+c[i]}

		13.	计数问题1
			-----砝码称重
			f[f[0]+1]=f[j]+k*w[j];
			(1<=i<=n;  1<=j<=f[0]; 1<=k<=a[i];)

		14.	递推天地1
			------核电站问题
			f[-1]:=1;  f[0]:=1;                        
			f[i]:=2*f[i-1]-f[i-1-m]         

		15.	递推天地2
			------数的划分
			f[i,j]:=f[i-j,j]+f[i-1,j-1];

		16.	最大子矩阵1
			-----一最大01子矩阵
			f[i,j]:=min(f[i-1,j],v[i,j-1],v[i-1,j-1])+1;    
			ans:=maxvalue(f);                            

		17.	判定性问题1
			-----能否被4整除
			g[1,0]:=true; g[1,1]:=false; g[1,2]:=false; g[1,3]:=false;
			g[i,j]:=g[i-1,k] and ((k+a[i,p]) mod 4 = j) 

		18.	判定性问题2
			-----能否被k整除
			f[I,j±n[i] mod k]:=f[i-1,j];      -k<=j<=k; 1<=i<=n

		20.	线型动态规划2
-----方块消除游戏
			f[i,i-1,0]:=0
			f[i,j,k]:=max{f[i,j-1,0]+sqr(len(j)+k),
				      f[i,p,k+len[j]]+f[p+1,j-1,0]}
			ans:=f[1,m,0]

		21.	线型动态规划3
			-----最长公共子串，LCS问题
			f[i,j]={0		(i=0)&(j=0);
				f[i-1,j-1]+1	(i>0,j>0,x[i]=y[j]);
				max{f[i,j-1]+f[i-1,j]}} (i>0,j>0,x[i]<>y[j]);

		22.	最大子矩阵2
			-----最大带权01子矩阵O(n^2*m)
			枚举行的起始，压缩进数列，求最大字段和，遇0则清零

23.    	资源问题4
			-----装箱问题(判定性01背包)
			f[j]:=(f[j] or f[j-v[i]]);
		

		24.	数字三角形1
			-----朴素の数字三角形
			f[i,j]:=max(f[i+1,j]+a[I,j],f[i+1,j+1]+a[i,j]); 

		25.	数字三角形2
			-----晴天小猪历险记之Hill
			同一阶段上暴力动态规划
                if[i,j]:=min(f[i,j-1],f[I,j+1],f[i-1,j],f[i-1,j-1])+a[i,j]

		26.	双向动态规划1
			数字三角形3
			-----小胖办证
			f[i,j]:=max(f[i-1,j]+a[i,j],f[i,j-1]+a[i,j],f[i,j+1]+a[i,j])

		27. 数字三角形4
			-----过河卒
			//边界初始化
			f[i,j]:=f[i-1,j]+f[i,j-1];

		28.	数字三角形5
			-----朴素的打砖块
			f[i,j,k]:=max(f[i-1,j-k,p]+sum[i,k],f[i,j,k]);			

		29.	数字三角形6
			-----优化的打砖块
			f[I,j,k]:=max{g[i-1,j-k,k-1]+sum[I,k]}

		30.	线性动态规划3
			-----打鼹鼠’
			f[i]:=f[j]+1;(abs(x[i]-x[j])+abs(y[i]-y[j])<=t[i]-t[j])

		31.	树形动态规划3
			-----贪吃的九头龙
			 

		32.	状态压缩动态规划1
			-----炮兵阵地
			Max(f[Q*(r+1)+k],g[j]+num[k]) 
			If (map[i] and plan[k]=0) and
               ((plan[P] or plan[q]) and plan[k]=0) 

		33.	递推天地3
			-----情书抄写员
			f[i]:=f[i-1]+k*f[i-2]

		34.	递推天地4
			-----错位排列
			f[i]:=(i-1)(f[i-2]+f[i-1]);
			f[n]:=n*f[n-1]+(-1)^(n-2);

		35.	递推天地5
			-----直线分平面最大区域数
			f[n]:=f[n-1]+n
			    :=n*(n+1) div 2 + 1;

		36.	递推天地6
			-----折线分平面最大区域数
			f[n]:=(n-1)(2*n-1)+2*n;

		37.	递推天地7
			-----封闭曲线分平面最大区域数
			f[n]:=f[n-1]+2*(n-1)
			    :=sqr(n)-n+2;
38	递推天地8
			-----凸多边形分三角形方法数
			f[n]:=C(2*n-2,n-1) div n;
			对于k边形
			f[k]:=C(2*k-4,k-2) div (k-1); //(k>=3)

		39	递推天地9
			-----Catalan数列一般形式
			1,1,2,5,14,42,132
			f[n]:=C(2k,k) div (k+1);

		40	递推天地10
			-----彩灯布置
			排列组合中的环形染色问题
			f[n]:=f[n-1]*(m-2)+f[n-2]*(m-1);   (f[1]:=m; f[2]:=m(m-1);

		41	线性动态规划4
			-----找数
			线性扫描
			 sum:=f[i]+g[j];
    		 (if sum=Aim then getout; if sum<Aim then inc(i) else inc(j);)
  
		42	线性动态规划5
			-----隐形的翅膀
            min:=min{abs(w[i]/w[j]-gold)};
             if w[i]/w[j]<gold then inc(i) else inc(j);
		
		43	剖分问题5
			-----最大奖励
			f[i]:=max(f[i],f[j]+(sum[j]-sum[i])*i-t

		44	最短路1
			-----Floyd
			f[i,j]:=max(f[i,j],f[i,k]+f[k,j]);
  			ans[q[i,j,k]]:=ans[q[i,j,k]]+s[i,q[i,j,k]]*s[q[i,j,k],j]/s[i,j];
45	剖分问题6
-----小H的小屋
F[l,m,n]:=f[l-x,m-1,n-k]+S(x,k);

46	计数问题2
-----陨石的秘密（排列组合中的计数问题）
Ans[l1,l2,l3,D]:=f[l1+1,l2,l3,D+1]-f[l1+1,l2,l3,D];
F[l1,l2,l3,D]:=Sigma(f[o,p,q,d-1]*f[l1-o,l2-p,l3-q,d]);

47	线性动态规划
------合唱队形
两次F[i]:=max{f[j]+1}＋枚举中央结点

48	资源问题
------明明的预算方案：加花的动态规划
f[i,j]:=max(f[i,j],f[l,j-v[i]-v[fb[i]]-v[fa[i]]]+v[i]*p[i]+v[fb[i]]*p[fb[i]]+v[fa[i]]*p[fa[i]]);

49	资源问题
-----化工场装箱员
 
50	树形动态规划
-----聚会的快乐
f[i,2]:=max(f[i,0],f[i,1]);
f[i,1]:=sigma(f[t[i]^.son,0]);
f[i,0]:=sigma(f[t[i]^.son,3]);


51	树形动态规划
-----皇宫看守
f[i,2]:=max(f[i,0],f[i,1]);
f[i,1]:=sigma(f[t[i]^.son,0]);
f[i,0]:=sigma(f[t[i]^.son,3]);

52	递推天地
-----盒子与球
f[i,1]:=1;
f[i,j]:=j*(f[i-1,j-1]+f[i-1,j]);

53	双重动态规划
-----有限的基因序列
f[i]:=min{f[j]+1}
g[c,i,j]:=(g[a,i,j] and g[b,i,j]) or (g[c,i,j])

54	最大子矩阵问题
-----居住空间
            f[i,j,k]:=min(min(min(f[i-1,j,k],f[i,j-1,k]),
                         min(f[i,j,k-1],f[i-1,j-1,k])),
                                min(min(f[i-1,j,k-1],f[i,j-1,k-1]),
                                f[i-1,j-1,k-1]))+1;
55	线性动态规划
------日程安排
f[i]:=max{f[j]}+P[I]; (e[j]<s[i])

56	递推天地
------组合数
C[I,j]:=C[i-1,j]+C[I-1,j-1]
C[I,0]:=1
		
57	树形动态规划
-----有向树k中值问题
F[I,r,k]:=max{max{f[l[i],I,j]+f[r[i],I,k-j-1]},f[f[l[i],r,j]+f[r[i],r,k-j]+w[I,r]]}

58	树形动态规划
-----CTSC 2001选课
F[I,j]:=w[i](if i∈P)+f[l[i],k]+f[r[i],m-k](0≤k≤m)(if l[i]<>0)

59	线性动态规划
-----多重历史
f[i,j]:=sigma{f[i-k,j-1]}(if checked)

60	背包问题(+-1背包问题+回溯)
-----CEOI1998 Substract
f[i,j]:=f[i-1,j-a[i]] or f[i-1,j+a[i]]

61	线性动态规划(字符串)
-----NOI 2000 古城之谜
f[i,1,1]:=min{f[i+length(s),2,1], f[i+length(s),1,1]+1}		f[i,1,2]:=min{f[i+length(s),1,2]+words[s],f[i+length(s),1,2]+words[s]}

62	线性动态规划
-----最少单词个数
f[i,j]:=max{f[I,j],f[u-1,j-1]+l}

63	线型动态规划
-----APIO2007 数据备份
状态压缩＋剪掉每个阶段j前j*2个状态和j*2+200后的状态贪心动态规划
f[i]:=min(g[i-2]+s[i],f[i-1]);
64	树形动态规划
-----APIO2007 风铃
f[i]:=f[l]+f[r]+{1 (if c[l]<c[r])}
g[i]:=1(d[l]<>d[r]) 0(d[l]=d[r])
g[l]=g[r]=1 then Halt;

65	地图动态规划
-----NOI 2005 adv19910
F[t,i,j]:=max{f[t-1,i-dx[d[[t]],j-dy[d[k]]]+1],f[t-1,i,j];

66	地图动态规划
-----优化的NOI 2005 adv19910
F[k,i,j]:=max{f[k-1,i,p]+1} j-b[k]<=p<=j;

67	目标动态规划
-----CEOI98 subtra
F[I,j]:=f[I-1,j+a[i]] or f[i-1,j-a[i]]

68	目标动态规划
----- Vijos 1037搭建双塔问题
F[value,delta]:=g[value+a[i],delta+a[i]] or g[value,delta-a[i]]

69	树形动态规划
-----有线电视网
f[i,p]:=max(f[i,p],f[i,p-q]+f[j,q]-map[i,j])
	   leaves[i]>=p>=l, 1<=q<=p;

70	地图动态规划
-----vijos某题
F[I,j]:=min(f[i-1,j-1],f[I,j-1],f[i-1,j]);

71	最大子矩阵问题
-----最大字段和问题
f[i]:=max(f[i-1]+b[i],b[i]); f[1]:=b[1]

72	最大子矩阵问题
-----最大子立方体问题
枚举一组边i的起始，压缩进矩阵 B[I,j]+=a[x,I,j]
枚举另外一组边的其实，做最大子矩阵

73	括号序列
-----线型动态规划
f[I,j]:=min(f[I,j],f[i+1,j-1](s[i]s[j]=”()”or(”[]”)),
f[I+1,j+1]+1 (s[j]=”(”or”[” ] , f[I,j-1]+1(s[j]=”)”or”]” )

74	棋盘切割
-----线型动态规划
f[k,x1,y1,x2,y2]=min{min{f[k-1,x1,y1,a,y2]+s[a+1,y1,x2,y2],
f[k-1,a+1,y1,x2,y2]+s[x1,y1,a,y2]
min{}}

75	概率动态规划
-----聪聪和可可(NOI2005)
x:=p[p[i,j],j]
f[I,j]:=(f[x,b[j,k]]+f[x,j])/(l[j]+1)+1
f[I,i]=0
f[x,j]=1

76	概率动态规划
-----血缘关系
F[A, B]=(f[A0, B]+P[A1, B])/2
f[I,i]=1
f[I,j]=0(I,j无相同基因)

77	线性动态规划
-----决斗
F[I,j]=(f[I,j] and f[k,j]) and (e[I,k] or e[j,k]),i<k<j

78	线性动态规划
-----舞蹈家
F[x,y,k]=min(f[a[k],y,k+1]+w[x,a[k]],f[x,a[k],k+1]+w[y,a[k]])

79	线性动态规划
-----积木游戏
F[I,a,b,k]=max(f[I,a+1,b,k],f[i+1,a+1,a+1,k’],f[I,a+1,a+1,k’])

80	树形动态规划（双次记录）
-----NOI2003 逃学的小孩
朴素的话枚举节点i和离其最远的两个节点 j,k O(n^2)
			每个节点记录最大的两个值，并记录这最大值分别是从哪个相邻节点传过来的。当遍历到某个孩子节点的时候，只需检查最大值是否是从该孩子节点传递来的。如果是，就取次大，否则取最大值

81	树形动态规划(完全二叉树)
-----NOI2006 网络收费
			F[I,j,k]表示在点i所管辖的所有用户中，有j个用户为A，在I的每个祖先u上，如果N[a]>N[b]则标0否则标1，用二进制状态压缩进k中，在这种情况下的最小花费
			F[I,j,k]:=min{f[l,u,k and (s[i]<<(i-1))]+w1,f[r,j-u,k and(s[i]<<(i-1))]}

82	树形动态规划
-----IOI2005 河流
			F[i]:=max

83	记忆化搜索
-----Vijos某题,忘了
F[pre,h,m]:=sigma{SDP(I,h+1,M+i)}  (pre<=i<=M＋1)

84	状态压缩动态规划
-----APIO 2007 动物园
f[I,k]:=f[i-1,k and not (1<<4)] + NewAddVal

85	树形动态规划
-----访问术馆
f[i,j-c[i]×2]:= max ( f[l[i],k], f[r[i],j-c[i]×2-k] )

86	字符串动态规划
-----Ural 1002 Phone
if exist(copy(s,j,i-j)) then f[i]:=min(f[i],f[j]+1);

87	多进程动态规划
-----CEOI 2005 service
Min( f[i,j,k], f[i-1,j,k] + c[t[i-1],t[i]] ) 
Min( f[i,t[i-1],k], f[i-1,j,k] + c[j,t[i]] ) 
Min( f[i,j,t[i-1]], f[i-1,j,k] + c[k,t[i]] )

88	多进程动态规划
-----Vijos1143 三取方格数
max(f[i,j,k,l],f[i-1,j-R[m,1],k-R[m,2],l-R[m,3]]);
if (j=k) and (k=l) then inc(f[i,j,k,l],a[j,i-j]) else
if (j=k) then inc(f[i,j,k,l],a[j,i-j]+a[l,i-l]) else 
if (k=l) then inc(f[i,j,k,l],a[j,i-j]+a[k,i-k]) else
if (j=l) then inc(f[i,j,k,l],a[j,i-j]+a[k,i-k]) else
inc(f[i,j,k,l],a[j,i-j]+a[k,i-k]+a[l,i-l]);

89	线型动态规划
-----IOI 2000 邮局问题
f[i,j]:=min(f[I,j],f[k,j-1]+d[k+1,i]);

90	线型动态规划
-----Vijos 1198 最佳课题选择
if j-k>=0 then Min(f[i,j],f[i-1,j-k]+time(i,k));
91	背包问题
----- USACO Raucous Rockers
多个背包，不可以重复放物品，但放物品的顺序有限制。
   	F[I,j,k]表示决策到第i个物品、第j个背包，此背包花费了k的空间。
f[I,j,k]:=max(f[I-1,j,k],f[I-1,j,k-t[i]]+p[i],f[i-1,j-1,maxtime-t[i]]) 

92	多进程动态规划
-----巡游加拿大（IOI95、USACO）
d[i,j]=max{d[k,j]+1(a[k,i] & j<k<i),d[j,k]+1(a[I,j] & (k<j))}。

f[i,j]表示从起点出发，一个人到达i，另一个人到达j时经过的城市数。d[i,j]=d[j,i]，所以我们限制i>j
分析状态(i,j)，它可能是(k,j)(j<k<i)中k到达i得到（方式1），也可能是(j,k)(k<j)中k超过j到达i得到（方式2）。但它不能是(i,k)(k<j)中k到达j得到，因为这样可能会出现重复路径。即使不会出现重复路径，那么它由(j,k)通过方式2同样可以得到，所以不会遗漏解 时间复杂度O(n3) 

93	动态规划
-----ZOJ cheese
f[i,j]:=f[i-kk*zl[u,1],j-kk*zl[u,2]]+a[i-kk*zl[u,1],j-kk*zl[u,2]]

94	动态规划
-----NOI 2004 berry 线性
F[I,1]:=s[i]
F[I,j]:=max{min{s[i]-s[l-1]},f[l-1,j-1]} (2≤j≤k, j≤l≤i)

95	动态规划
-----NOI 2004 berry 完全无向图
F[I,j]:=f[i-1,j] or (j≥w[i]) and (f[i-1,j-w[i]])

96	动态规划
-----石子合并 四边形不等式优化
m[i,j]=max{m[i+1,j], m[i,j-1]}+t[i,j]   

97	动态规划
-----CEOI 2005 service
（k≥long[i]，i≥1）g[i, j, k]=max{g[i-1,j,k-long[i]]+1，g[i-1,j,k]}
（k<long[i]，i≥1） g[i, j, k]=max{g[i-1,j-1,t-long[i]]+1，g[i-1,j,k]}
(0≤j≤m， 0≤k<t) g[0,j,k]=0;
 ans:=g[n,m,0]。

状态优化：g[i, j]=min{g[i-1,j]，g[i-1,j-1]+long[i]}
其中(a, b)+long[i]=(a’, b’)的计算方法为：
当b+long[i] ≤t时： a’=a;       b’=b+long[i];
当b+long[i] ＞t时： a’=a+1;   b’=long[i];
规划的边界条件：
当0≤i≤n时，g[i,0]=(0,0) 

98	动态规划
-----AHOI 2006宝库通道
			f[k]:=max{f[k-1]+x[k,j]-x[k,i-1], x[k,j]-x[k,i-1]}

99	动态规划
-----Travel
A) 费用最少的旅行计划。
设f[i]表示从起点到第i个旅店住宿一天的最小费用；g[i]表示从起点到第i个旅店住宿一天，在满足最小费用的前提下所需要的最少天数。那么：
f[i]=f[x]+v[i],    g[i]=g[x]+1
x满足：
1、	x<i，且d[i] – d[x] <= 800（一天的最大行程）。
2、	对于所有的t < i, d[i] – d[t] <= 800，都必须满足：
A. g[x] < g[t](f[x] = f[t]时)     B. f[x] < f[t]  (其他情况)
f[0] = 0，g[0] = 0。 Ans:=f[n + 1]，g[n+1]。

B). 天数最少的旅行计划。
方法其实和第一问十分类似。
设g’[i]表示从起点到第i个旅店住宿一天的最少天数；f’[i]表示从起点到第i个旅店住宿一天，在满足最小天数前提下所需要的最少费用。那么：
g’[i] = g’[x] + 1,    f’[i] = f’[x] + v[i]
x满足：
1、	x<i，且d[i] – d[x] <= 800（一天的最大行程）。
2、	对于所有的t < i, d[i] – d[t] <= 800，都必须满足：
f’[x] < f’[t]       g’[x] = g’[t]时
g’[x] < g’[t]        其他情况
f’[0] = 0，g’[0] = 0。 Ans:=f’[n + 1]，g’[n+1]。


100	动态规划
-----NOI 2007 cash
y:=f[j]/(a[j]*c[j]+b[j]);
g:=c[j]*y*a[i]+y*b[i];
f[i]:=max(f[i],g)


### DP 

动态规划  Dynamic Programming
提要    本文介绍了动态规划的基本思想和基本步骤，通过实例研究了利用动态规划设计算法的具体途径，讨论了动态规划的一些实现技巧，并将动态规划和其他一些算法作了比较，最后还简单介绍了动态规划的数学理论基础和当前最新的研究成果。
目录
引言
动态规划的基本概念
动态规划的基本定理和基本方程
动态规划的适用条件
动态规划的基本思想
动态规划的基本步骤
动态规划的实例分析
动态规划的技巧
动态规划实现中的问题
动态规划与其他算法的比较
动态规划的理论基础
其他资料

function MinDistance(v):integer;
begin
 if v=E then return 0
  else
   begin
    min:=maxint;
    for 所有没有访问过的节点i do
     if v和i相邻 then
      begin
        标记i访问过了;
        t:=v到i的距离+MinDistance(i);
        标记i未访问过;       
        if t
      end; 
   end;
end;
 
开始时标记所有的顶点未访问过，MinDistance(A)就是从A到E的最短距离。
这个程序的效率如何呢？我们可以看到，每次除了已经访问过的城市外，其他城市都要访问，所以时间复杂度为O(n!)，这是一个“指数级”的算法，那么，还有没有更好的算法呢？
首先，我们来观察一下这个算法。在求从B1到E的最短距离的时候，先求出从C2到E的最短距离；而在求从B2到E的最短距离的时候，又求了一遍从C2到E的最短距离。也就是说，从C2到E的最短距离我们求了两遍。同样可以发现，在求从C1、C2到E的最短距离的过程中，从D1到E的最短距离也被求了两遍。而在整个程序中，从D1到E的最短距离被求了四遍。如果在求解的过程中，同时将求得的最短距离"记录在案"，随时调用，就可以避免这种情况。于是，可以改进该算法，将每次求出的从v到E的最短距离记录下来，在算法中递归地求MinDistance(v)时先检查以前是否已经求过了MinDistance(v)，如果求过了则不用重新求一遍，只要查找以前的记录就可以了。这样，由于所有的点有n个，因此不同的状态数目有n个，该算法的数量级为O(n)。
更进一步，可以将这种递归改为递推，这样可以减少递归调用的开销。
请看图1，可以发现，A只和Bi相邻，Bi只和Ci相邻,...，依此类推。这样，我们可以将原问题的解决过程划分为4个阶段，设

显然可以递推地求出F1(A)，也就是从A到E的最短距离。这种算法的复杂度为O(n)，因为所有的状态总数（节点总数）为n，对每个状态都只要遍历一次，而且程序很简洁。
具体算法如下：
procedure DynamicProgramming;
 begin
  F5[E]:=0;
  for i:=4 downto 1 do
     for each u ∈Sk do
      begin
       Fk[u]:=无穷大;
       for each v∈Sk+1∩δ(u) do
         if Fk[u]>w(u,v)+Fk+1[v] then Fk[u]:=w(u,v)+Fk+1[v];
   end;
  输出F1[A];
 end;
这种高效算法，就是动态规划算法。
二、动态规划的基本概念
1、动态规划的发展及研究内容
动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著Dynamic Programming，这是该领域的第一本著作。
动态规划问世以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。
虽然动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。
2、多阶段决策过程与多阶段决策问题
多阶段决策过程，是指这样的一类特殊的活动过程，问题可以按时间顺序分解成若干相互联系的阶段，在每一个阶段都要做出决策，全部过程的决策是一个决策序列。要使整个活动的总体效果达到最优的问题，称为多阶段决策问题。
例1是一个多阶段决策问题的例子，下面是另一个多阶段决策问题的例子：
[例2] 生产计划问题    工厂生产某种产品，每单位(千件)的成本为1(千元)，每次开工的固定成本为3(千元)，工厂每季度的最大生产能力为6(千件)。经调查，市场对该产品的需求量第一、二、三、四季度分别为 2，3，2，4(千件)。如果工厂在第一、二季度将全年的需求都生产出来，自然可以降低成本(少付固定成本费)，但是对于第三、四季度才能上市的产品需付存储费，每季每千件的存储费为0.5(千元)。还规定年初和年末这种产品均无库存。试制订一个生产计划，即安排每个季度的产量，使一年的总费用(生产成本和存储费)最少。
3、决策过程的分类
根据过程的时间变量是离散的还是连续的，分为离散时间决策过程(discrete-time decision process)，即多阶段决策过程和连续时间决策过程(continuous-time decision process)；根据过程的演变是确定的还是随机的，分为确定性决策过程(deterministic decision process)和随机性决策过程(stochastic decision process)，其中应用最广的是确定性多阶段决策过程。
4、动态规划模型的基本要素
一个多阶段决策过程最优化问题的动态规划模型通常包含以下要素：
1）阶段
阶段(step)是对整个过程的自然划分。通常根据时间顺序或空间特征来划分阶段，以便按阶段的次序解优化问题。阶段变量一般用k=1,2,..,n表示。在例1中由A出发为k=1，由Bi(i=1,2)出发为k=2，依此下去从Di(i=1,2,3)出发为k=4，共n=4个阶段。在例2中按照第一、二、三、四季度分为k=1,2,3,4，共4个阶段。
2）状态
状态(state)表示每个阶段开始时过程所处的自然状况。它应该能够描述过程的特征并且具有无后向性，即当某阶段的状态给定时，这个阶段以后过程的演变与该阶段以前各阶段的状态无关，即每个状态都是过去历史的一个完整总结。通常还要求状态是直接或间接可以观测的。
描述状态的变量称状态变量(state variable)。变量允许取值的范围称允许状态集合(set of admissible states)。用xk表示第k阶段的状态变量，它可以是一个数或一个向量。用Xk表示第k阶段的允许状态集合。在例1中x2可取B1，B2，X2={B1,B2}。
n个阶段的决策过程有n+1个状态变量，xn+1表示xn演变的结果，在例1中x5取E。
根据过程演变的具体情况，状态变量可以是离散的或连续的。为了计算的方便有时将连续变量离散化；为了分析的方便有时又将离散变量视为连续的。
状态变量简称为状态。
3）决策
当一个阶段的状态确定后，可以作出各种选择从而演变到下一阶段的某个状态，这种选择手段称为决策(decision)，在最优控制问题中也称为控制(control)。
描述决策的变量称决策变量(decision variable)。变量允许取值的范围称允许决策集合(set of admissible decisions)。用uk(xk)表示第k阶段处于状态xk时的决策变量，它是xk的函数，用Uk(xk)表示了xk的允许决策集合。在例1中u2(B1)可取C1,C2,C3。
决策变量简称决策。
4）策略
决策组成的序列称为策略(policy)。由初始状态x1开始的全过程的策略记作p1n(x1)，即p1n(x1)={u1(x1),u2(x2),...，un(xn)}。由第k阶段的状态xk开始到终止状态的后部子过程的策略记作pkn(xk)，即pkn(xk)={uk(xk),uk+1(xk+1),...，un(xn)}。类似地，由第k到第j阶段的子过程的策略记作pkj(xk)={uk(xk),uk+1(xk+1),...，uj(xj)}。对于每一个阶段k的某一给定的状态xk，可供选择的策略pkj(xk)有一定的范围，称为允许策略集合(set of admissible policies)，用P1n(x1),Pkn(xk),Pkj(xk)表示。
5）状态转移方程
在确定性过程中，一旦某阶段的状态和决策为已知，下阶段的状态便完全确定。用状态转移方程(equation of state)表示这种演变规律，写作

在例1中状态转移方程为：xk+1=uk(xk)
6）指标函数和最优值函数
指标函数(objective function) 是衡量过程优劣的数量指标，它是关于策略的数量函数，从阶段k到阶段n的指标函数用Vkn(xk,pkn(xk))表示，k=1,2,...,n。
能够用动态规划解决的问题的指标函数应具有可分离性，即Vkn可表为xk,uk,Vk+1 n 的函数，记为：

这些形式下第k到第j阶段子过程的指标函数为Vkj(xk,uk,xk+1,...,xj+1)。可以发现，上述(3)-(5)三个指标函数的形式都满足最优性原理。在例1中指标函数为(3)的形式，其中vj(xj,uj)是边j,uj(xj)>的权（边的长度）,uj(xj)表示从xj出发根据决策uj(xj)下一步所到达的节点。
根据状态转移方程，指标函数Vkn还可以表示为状态xk和策略pkn的函数，即Vkn(xk,pkn)。在xk给定时指标函数Vkn对pkn的最优值称为最优值函数(optimal value function)，记作fk(xk)，即

其中opt可根据具体情况取max或min。上式的意义是，对于某个阶段k的某个状态xk，从该阶段k到最终目标阶段n的最优指标函数值等于从xk出发取遍所有能策略pkn所得到的最优指标值中最优的一个。
7）最优策略和最优轨线
使指标函数Vkn达到最优值的策略是从k开始的后部子过程的最优策略，记作pkn*={uk*,..un*},p1n*又是全过程的最优策略，简称最优策略(optimal policy)。从初始状态x1(=x1*)出发，过程按照p1n*和状态转移方程演变所经历的状态序列{x1*,x2*,..,xn+1*}称最优轨线(optimal trajectory)。
三、动态规划的基本定理和基本方程
动态规划发展的早期阶段，从简单逻辑出发给出了所谓最优性原理，然后在最优策略存在的前提下导出基本方程，再由这个方程求解最优策略。后来在动态规划的应用过程中发现，最优性原理不是对任何决策过程普遍成立，它与基本方程不是无条件等价，二者之间也不存在任何确定的蕴含关系。基本方程在动态规划中起着更为本质的作用。
[基本定理]   对于初始状态x1∈X1，策略p1n*={u1*,..un*}是最优策略的充要条件是对于任意的k,1

四、动态规划的适用条件
任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性。
1.最优化原理（最优子结构性质）
最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。

这两个问题看起来很相似。但实质上是不同的。为了方便讨论，我将每个顶点标记了号码。由于必然经过最右边的顶点7，所以一条路(P1-P2)可以看成两条路（P1-7）与(P2-7)的结合。所以，这个问题的状态可以用两条道路结合的形式表示。我们可以把这些状态中，两条路中起始顶点相同的状态归于一个阶段，设为阶段[P1,P2]。
那么，对于Bitonic旅行路线问题来说，阶段[P1,P2]如果可以由阶段[Q1,Q2]推出，则必须满足的条件就是:P1无后向性，可以用动态规划来解决。
有些问题乍一看好像有后向性，但如果按照某种合理的方式重新划分阶段，就可以发现其本质上是无后向性的，所以关键是阶段的合理划分，这一点将在动态规划的技巧中详细阐述。
3.子问题的重叠性
在例1中我们看到，动态规划将原来具有指数级复杂度的搜索算法改进成了具有多项式时间的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。以Bitonic旅行路线问题为例，这个问题也可以用搜索算法来解决。动态规划的时间复杂度为O(n2)，搜索算法的时间复杂度为O(n!) ，但从空间复杂度来看，动态规划算法为O(n2)，而搜索算法为O(n)，搜索算法反而优于动态规划算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间。
设原问题的规模为n，容易看出，当子问题树中的子问题总数是n的超多项式函数，而不同的子问题数只是n的多项式函数时，动态规划法显得特别有意义，此时动态规划法具有线性时间复杂性。所以，能够用动态规划解决的问题还有一个显著特征：子问题的重叠性。这个性质并不是动态规划适用的必要条件，但是如果该性质无法满足，动态规划算法同其他算法相比就不具备优势。


图5 动态规划设计的一般模式
    上述提供了动态规划方法的一般模式，对于简单的动态规划问题，可以按部就班地进行动态规划的设计。
    下面，给出一个利用动态规划方法求解的典型例子。 
    【例题6】数字三角形问题。图6示出了一个数字三角形宝塔。数字三角形中的数字为不超过100的整数。现规定从最顶层走到最底层，每一步可沿左斜线向下或右斜线向下走。
  任务一：假设三角形行数≤10，键盘输入一个确定的整数值M，编程确定是否存在一条路径，使得沿着该路径所经过的数字的总和恰为M，若存在则给出所有路径，若不存在，则输出“NO Answer!”字样。
    任务二：假设三角形行数≤100，编程求解从最顶层走到最底层的一条路径，使得沿着该路径所经过的数字的总和最大，输出最大值。
    输人数据：由文件输入数据，任务一中文件第一行是三角形的行数N和整数值 M。以后的N行分别是从最顶层到最底层的每一层中的数字。任务二中文件数据格式同任务一，只是第一行中没有整数值M。在例子中任务二的文件数据表示如下：

    【分析】对于这一问题，很容易想到用枚举的方法去解决，即列举出所有路径并记录每一条路径所经过的数字总和。然后判断数字总和是否等于给定的整数值M或寻找出最大的数字总和，这一想法很直观，而且对于任务一，由于数字三角形的行数不大(<＝10)，因此其枚举量不是很大，应该能够实现。但对于任务二，如果用枚举的方法，当三角形的行数等于100时，其枚举量之大是可想而知的，显然，枚举法对于任务二的求解并不适用。其实，只要对对任务二稍加分析，就可以得出一个结论：
    如果得到一条由顶至底的某处的一条最佳路径，那么对于该路径上的每一个中间点来说，由顶至该中间点的路径所经过的数字和也为最大。因此该问题是一个典型的多阶段决策最优化的问题。算法设计与分析如下：
    对于任务一，合理地确认枚举的方法，可以优化问题的解法。由于从塔顶到底层每次都只有两种走法，即左或右。设“0”表示左，  “1”表示右，对于层数为N的数字塔，从顶到底的一种走法可用一个N-1位的二进制数表示。如例中二进制数字串1011，其对应的路径应该是：8—1—4—6。这样就可以用一个N—l位的二进制数来模拟走法和确定解的范围。穷举出从0到2n-1个十进制数所对应的N-1位二进制串对应的路径中的数字总和，判定其是否等于M而求得问题的解。
    对于任务二，采用动态规划中的顺推解法。按三角形的行划分阶段，若行数为 n，则可把问题看做一个n-1个阶段的决策问题。从始点出发，依顺向求出第一阶段、第二阶段……第n—1阶段中各决策点至始点的最佳路径，最终求出始点到终点的最佳路径。
    设：fk(Uk)为从第k阶段中的点Uk至三角形顶点有一条最佳路径，该路径所经过的数字的总和最大，fk(Uk)表示为这个数字和；
    由于每一次决策有两个选择，或沿左斜线向下，或沿右斜线向下，因此设：
    Uk1为k-1阶段中某点Uk沿左斜线向下的点；
    Uk2为k-1阶段中某点Uk沿右斜线向下的点；
    dk(Uk1)为k阶段中Uk1的数字；dk(Uk2)为k阶段中Uk2的数字。
    因而可写出顺推关系式(状态转移方程)为：
    fk(Uk)=max{fk-1(Uk)+dk(Uk1)，fk-1(Uk)+dk(Uk2)}(k=1，2，3，…，n)
    f0(U0)＝0
    经过一次顺推，便可分别求出由顶至底N个数的N条路径，在这N条路径所经过的N个数字和中，最大值即为正确答案。
六、动态规划的基本思想
前文主要介绍了动态规划的一些理论依据，我们将前文所说的具有明显的阶段划分和状态转移方程的动态规划称为标准动态规划，这种标准动态规划是在研究多阶段决策问题时推导出来的，具有严格的数学形式，适合用于理论上的分析。在实际应用中，许多问题的阶段划分并不明显，这时如果刻意地划分阶段法反而麻烦。一般来说，只要该问题可以划分成规模更小的子问题，并且原问题的最优解中包含了子问题的最优解（即满足最优子化原理），则可以考虑用动态规划解决。
动态规划的实质是分治思想和解决冗余，因此，动态规划是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免计算重复的子问题，以解决最优化问题的算法策略。
由此可知，动态规划法与分治法和贪心法类似，它们都是将问题实例归纳为更小的、相似的子问题，并通过求解子问题产生一个全局最优解。其中贪心法的当前选择可能要依赖已经作出的所有选择，但不依赖于有待于做出的选择和子问题。因此贪心法自顶向下，一步一步地作出贪心选择；而分治法中的各个子问题是独立的 (即不包含公共的子子问题)，因此一旦递归地求出各子问题的解后，便可自下而上地将子问题的解合并成问题的解。但不足的是，如果当前选择可能要依赖子问题的解时，则难以通过局部的贪心策略达到全局最优解；如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题。
解决上述问题的办法是利用动态规划。该方法主要应用于最优化问题，这类问题会有多种可能的解，每个解都有一个值，而动态规划找出其中最优(最大或最小)值的解。若存在若干个取最优值的解的话，它只取其中的一个。在求解过程中，该方法也是通过求解局部子问题的解达到全局最优解，但与分治法和贪心法不同的是，动态规划允许这些子问题不独立，(亦即各子问题可包含公共的子子问题)也允许其通过自身子问题的解作出选择，该方法对每一个子问题只解一次，并将结果保存起来，避免每次碰到时都要重复计算。
因此，动态规划法所针对的问题有一个显著的特征，即它所对应的子问题树中的子问题呈现大量的重复。动态规划法的关键就在于，对于重复出现的子问题，只在第一次遇到时加以求解，并把答案保存起来，让以后再遇到时直接引用，不必重新求解。
七、动态规划算法的基本步骤
设计一个标准的动态规划算法，通常可按以下几个步骤进行：
划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。注意这若干个阶段一定要是有序的或者是可排序的（即无后向性），否则问题就无法用动态规划求解。
选择状态：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
确定决策并写出状态转移方程：之所以把这两步放在一起，是因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以，如果我们确定了决策，状态转移方程也就写出来了。但事实上，我们常常是反过来做，根据相邻两段的各状态之间的关系来确定决策。
写出规划方程（包括边界条件）：动态规划的基本方程是规划方程的通用形式化表达式。一般说来，只要阶段、状态、决策和状态转移确定了，这一步还是比较简单的。
动态规划的主要难点在于理论上的设计，一旦设计完成，实现部分就会非常简单。根据动态规划的基本方程可以直接递归计算最优值，但是一般将其改为递推计算，实现的大体上的框架如下：
 
 
标准动态规划的基本框架
1.  对fn+1(xn+1)初始化;    {边界条件}
2.  for k:=n downto 1 do
3.      for 每一个xk∈Xk do
4.        for 每一个uk∈Uk(xk) do
            begin
5.            fk(xk):=一个极值;                 {∞或－∞}
6.            xk+1:=Tk(xk,uk);                  {状态转移方程}
7.            t:=φ(fk+1(xk+1),vk(xk,uk));       {基本方程(9)式}
8.            if  t比fk(xk)更优 then fk(xk):=t; {计算fk(xk)的最优值}
           end; 
9.  t:=一个极值;                               {∞或－∞}
10. for 每一个x1∈X1 do
11.     if f1(x1)比t更优 then t:=f1(x1);       {按照10式求出最优指标}
12. 输出t;
但是，实际应用当中经常不显式地按照上面步骤设计动态规划，而是按以下几个步骤进行：
1)        分析最优解的性质，并刻划其结构特征。
2)        递归地定义最优值。
3)        以自底向上的方式或自顶向下的记忆化方法（备忘录法）计算出最优值。
4)        根据计算最优值时得到的信息，构造一个最优解。
步骤(1)--(3)是动态规划算法的基本步骤。在只需要求出最优值的情形，步骤(4)可以省略，若需要求出问题的一个最优解，则必须执行步骤(4)。此时，在步骤(3)中计算最优值时，通常需记录更多的信息，以便在步骤(4)中，根据所记录的信息，快速地构造出一个最优解。
八、动态规划的实例分析
下面我们将通过实例来分析动态规划的设计步骤和具体应用。例1已经在前文介绍过了。例1和例2是标准的动态规划，有明显的阶段和状态转移方程；例3、例4、例5、例6是没有明显阶段划分的动态规划，也是一般常见的形式，其中对例4、例5、例6作了比较详细的分析；例7是比较特殊的动态规划，例8是两重动态规划（即为了解决问题要进行两次动态规划）的例子。
 
例1 最短路径问题
例2 生产计划问题
例3 Bitonic旅行路线问题
例4 计算矩阵连乘积
例5 最长公共子序列
例6 凸多边形的最优三角剖分问题
例7 多边形计算
例8 字符识别
更多实例请参阅动态规划问题集
 
例1 生产计划问题
问题描述    工厂生产某种产品，每单位(千件)的成本为1(千元)，每次开工的固定成本为3(千元)，工厂每季度的最大生产能力为6(千件)。经调查，市场对该产品的需求量第一、二、三、四季度分别为 2，3，2，4(千件)。如果工厂在第一、二季度将全年的需求都生产出来，自然可以降低成本(少付固定成本费)，但是对于第三、四季度才能上市的产品需付存储费，每季每千件的存储费为0.5(千元)。还规定年初和年末这种产品均无库存。试制订一个生产计划，即安排每个季度的产量，使一年的总费用(生产成本和存储费)最少。
参考解答   这是一个明显的多阶段问题，我们按照计划时间自然划分阶段，状态定义为每阶段开始时的存储量xk，决策为每个阶段的产量uk，记每个阶段的需求量（已知）为dk，则状态转移方程为：
设每个阶段开工固定成本费用为a，生产单位数量产品的成本为b，每阶段单位数量产品的存储费用为ｃ，阶段指标为阶段的生产成本费用和存储费用之和，即：
指标函数Vkn为vk之和，最优值函数fk(xk)为从第k阶段的状态xk出发到过程终结的最小费用，满足
其中允许决策集合Uk由每阶段的最大生产能力决定，设过程终结时允许存储量为x0n+1，则终端条件为：
将以上各式代入到标准动态规划的框架中，就可以求得最优解。
例2  Bitonic旅行路线问题
问题描述   欧几里德货郎担问题是对平面给定的n个点确定一条连结各点的、闭合的游历路线问题。图7(a)给出了七个点问题的解。Bitonic旅行路线问题是欧几里德货郎担问题的简化，这种旅行路线先从最左边开始，严格地由左至右到最右边的点，然后再严格地由右至左到出发点，求路程最短的路径长度。图7（b）给出了七个点问题的解。

请设计一种多项式时间的算法，解决Bitonic旅行路线问题。
参考解答    首先将n个点按X坐标递增的顺序排列成一个序列L=<点1，点2，…，点n>。显然L[n]为最右点，L[1]为最左点。由于点1往返经过二次(出发一次，返回一次)，因此点1拆成两个点：L[0]=L[1]=点1。
设：
Wi,j -- 边的距离；

由该公式知计算C=AB总共需要pqr次的数乘。
现在的问题是，给定n个矩阵{A1,A2,…,An}。其中Ai与Ai+1是可乘的，i=1,2,…,n-1。要求计算出这n个矩阵的连乘积A1A2…An。
    由于矩阵乘法满足结合律，故连乘积的计算可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。若一个矩阵连乘积的计算次序已完全确定，也就是说该连乘积已完全加括号，则我们可以通过反复调用两个矩阵相乘的标准算法计算出矩阵连乘积。完全加括号的矩阵连乘积可递归地定义为：
单个矩阵是完全加括号的；
若矩阵连乘积A是完全加括号的，则A可表示为两个完全加括号的矩阵连乘积B和C的乘积并加括号，即A=(BC)。
例如，矩阵连乘积A1A2A3 A4可以有以下5种不同的完全加括号方式：
        (A1(A2(A3A4)))，
        (A1((A2A3)A4)),
        ((A1A2)(A3A4)),
        ((A1(A2A3))A4),
        (((A1A2)A3)A4)。
每一种完全加括号方式对应于一种矩阵连乘积的计算次序，而这种计算次序与计算矩阵连乘积的计算量有着密切的关系。
为了说明在计算矩阵连乘积时加括号方式对整个计算量的影响，我们来看一个计算3个矩阵{A1，A2，A3}的连乘积的例子。设这3个矩阵的维数分别为10×100，100×5和5×50。若按第一种加括号方式((A1A2)A3)来计算，总共需要10×100×5+10×5×50=7500次的数乘。若按第二种加括号方式(A1(A2A3))来计算，则需要的数乘次数为100×5×50+10×100×50=75000。第二种加括号方式的计算量是第一种加括号方式的计算量的10倍。由此可见，在计算矩阵连乘积时，加括号方式，即计算次序对计算量有很大影响。
于是，人们自然会提出矩阵连乘积的最优计算次序问题，即对于给定的相继n个矩阵{A1,A2,…,An}(其中Ai的维数为pi-1×pi ，i=1,2,…,n)，如何确定计算矩阵连乘积A1A2…An的一个计算次序(完全加括号方式)，使得依此次序计算矩阵连乘积需要的数乘次数最少。
说明：计算两个均为n×n的矩阵(即n阶方阵)相乘还有一种Strassen矩阵乘法，利用分治思想将2个n阶矩阵乘积所需时间从标准算法的O(n3)改进到O(nlog7)=O(n2.81)。目前计算两个n阶方阵相乘最好的计算时间上界是O(n2.367)。但无论如何，所需的乘法次数总随两个矩阵的阶而递增。在这道题中只考虑采用标准公式计算两个矩阵的乘积。
参考解答    解这个问题的最容易想到的方法是穷举搜索法。也就是列出所有可能的计算次序，并计算出每一种计算次序相应需要的计算量，然后找出最小者。然而，这样做计算量太大。事实上，对于n个矩阵的连乘积，设有P(n)个不同的计算次序。由于我们可以首先在第k个和第k+1个矩阵之间将原矩阵序列分为两个矩阵子序列，k=1,2,…,n-1；然后分别对这两个矩阵子序列完全加括号；最后对所得的结果加括号，得到原矩阵序列的一种完全加括号方式。所以关于P(n)，我们有递推式如下：

    下面我们来考虑用动态规划法解矩阵连乘积的最优计算次序问题。此问题是动态规划的典型应用之一。
1.分析最优解的结构
    首先，为方便起见，将矩阵连乘积AiAi+1…Aj简记为Ai…j。我们来看计算A1…n的一个最优次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，1<=k1…Ak)(Ak+1…An))。照此，我们要先计算A1…k和Ak+1…n，然后，将所得的结果相乘才得到A1…n。显然其总计算量为计算A1…k的计算量加上计算Ak+1…n的计算量，再加上A1…k与Ak+1…n相乘的计算量。
    这个问题的一个关键特征是：计算A1…n的一个最优次序所包含的计算A1…k的次序也是最优的。事实上，若有一个计算A1…k的次序需要的计算量更少，则用此次序替换原来计算A1…k的次序，得到的计算A1…n的次序需要的计算量将比最优次序所需计算量更少，这是一个矛盾。同理可知，计算A1…n的一个最优次序所包含的计算矩阵子链Ak+1…n的次序也是最优的。根据该问题的指标函数的特征也可以知道该问题满足最优化原理。另外，该问题显然满足无后向性，因为前面的矩阵链的计算方法和后面的矩阵链的计算方法无关。
2.建立递归关系
    对于矩阵连乘积的最优计算次序问题，设计算Ai…j ,1≤i≤j≤n，所需的最少数乘次数为m[i,j]，原问题的最优值为m[1,n]。
当i=j时，Ai…j=Ai为单一矩阵，无需计算，因此m[i,i]=0，i=1,2,…,n ；
当ii…j的最优次序在Ak和Ak+1之间断开，i≤ki-1pkpj
    由于在计算时我们并不知道断开点A的位置，所以A还未定。不过k的位置只有j-i个可能，即k∈{i,i+1,…,j-1}。因此k是这j-i个位置中计算量达到最小的那一个位置。从而m[i,j]可以递归地定义为：

   用动态规划算法解此问题，可依据递归式(2.1)以自底向上的方式进行计算，在计算过程中，保存已解决的子问题答案，每个子问题只计算一次，而在后面需要时只要简单查一下，从而避免大量的重复计算，最终得到多项式时间的算法。下面所给出的计算m[i,j]动态规划算法中，输入是序列P={p0,p1,…,pn}，输出除了最优值m[i,j]外，还有使
m[i,j] = m[i,k] + m[k+1,j] + pi-1pkpj
达到最优的断开位置k=s[i,j]，1≤i≤j≤n 。
 
Procedure MATRIX_CHAIN_ORDER(p); {计算矩阵链连乘的最优断开位置}
var
i,j,k,q:integer;
begin
  for j:=1 to n do {矩阵链的长度为n}
  for i:=j downto 1 do
    begin
      if i=j then m[i,j]:=0
             else begin
                    m[i,j]:=∞;
                    for k:=i to j-1 do
                      begin
                        q:=m[i,k]+m[k+1,j]+p[i-1]*p[k]*p[j];
                        if q
                            begin
                              m[i,j]:=q;
                              s[i,j]:=k;
                               {s[i,j]记录计算A[i..j]的最优断开位置k}
                            end;
                      end;
                  end;
    end;
end;
该算法按照
    m[1,1]
    m[2,2]   m[1,2]
    m[3,3]   m[2,3]   m[1,3]
    ...      ...      ...
    m[n,n]   m[n-1,n] ... ....  ... m[1,n]
的顺序根据公式(2.1)计算m[i,j]。
该算法的计算时间上界为O(n3)。算法所占用的空间显然为O(n2)。由此可见，动态规划算法比穷举搜索法要有效得多。
4.构造最优解
    算法MATRIX_CHAIN_ ORDER只是计算出了最优值，并未给出最优解。也就是说，通过MATRIX_CHAIN_ORDER的计算，我们只知道计算给定的矩阵连乘积所需的最少数乘次数，还不知道具体应按什么次序来做矩阵乘法才能达到数乘次数最少。
    然而，MATRIX_CHAIN_ORDER己记录了构造一个最优解所需要的全部信息。事实上，s[i,j]中的数k告诉我们计算矩阵链Ai…j的最佳方式应在矩阵Ak和Ak+1之间断开，即最优的加括号方式应为(A1...k)(Ak+1…n)。因此，从s[i,j]记录的信息可知计算A1…n的最优加括号方式为 (A1…s[1,n])(As[1,n]+1…n)。而计算A1…s[1,n]的最优加括号方式为(A1…s[1,s[1,n]])(As[1,s[1,n]]+1…s[1,n])。同理可以确定计算As[1,n]+1…n的最优加括号方式在s[s[1,n]+1,n]处断开。…照此递推下去，最终可以确定As[1,n]+1…n的最优完全加括号方式，即构造出问题的一个最优解。
    下面的算法MATRIX_CHAIN_MULTIPLY(A,s,i,j)是按s指示的加括号方式计算矩阵链A={A1,A2,…,An}的子链Ai…j的连乘积的算法。
Procdeure MATRIX_CHAIN_MULTIPLY(A,s,i,j);
begin
  if j>i then
           begin
             X←MATRIX_CHAIN_MULTIPLY(A,s,i,s[i,j]);
             Y←MATRIX_CHAIN_MULTIPLY(A,s,s[i,j]+1,j);
             return(MATRIX_MULTIPLY(X,Y)); {计算并返回矩阵X*Y的值}
           end
         else return(Ai);
end;
要计算A1…n只要调用MATRIX_CHAIN_MULTIPLY(A,s,1,n)即可。
    从算法MATRIX_CHAIN_ ORDER可以看出，该算法的有效性依赖于问题本身所具有的三个重要性质：最优子结构性质，无后向性和子问题重叠性质。一般说来，问题所具有的这三个重要性质是该问题可用动态规划算法求解的基本要素，这对于我们在设计求解具体问题的算法时，是否选择动态规划算法具有指导意义。下面我们着重研究最优子结构性质和子问题重叠性质以及动态规划法的一个变形—备忘录方法。
最优子结构
设计动态规划算法的第1步通常是要刻划最优解的结构。当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。
在矩阵连乘积最优计算次序问题中，我们注意到，若A1…n的最优完全加括号方式在Ak和Ak+1之间将矩阵链断开，则由该次序确定的子链A1…k和Ak+1…n的完全加括号方式也是最优的。也就是说该问题具有最优子结构性质。在分析该问题的最优子结构性质时，我们所用的方法是具有普遍性的。我们首先假设由问题的最优解导出的其子问题的解不是最优的，然后再设法证明在这个假设下可构造出一个比原问题最优解更好的解，从而导致矛盾。
在动态规划算法中，问题的最优子结构性质使我们能够以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。同时，它也使我们能在相对小的子问题空间中考虑问题。例如，在矩阵连乘积最优计算次序问题中，子问题空间是输人的矩阵链的所有不同的子链，它们的个数为θ(n2)。因而子问题空间的规模仅为θ(n2)。
重叠子问题
可用动态规划算法求解的问题应具备的另一基本要素是子问题的重叠性质。也就是说，在用递归算法自顶向下解此问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。通常，不同的子问题的个数随输人问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。
为了说明这一点，我们来看在计算矩阵连乘积最优计算次序时，利用公式(2.1)直接计算Ai…j的递归算法。
Function RECURSIVE_MATRIX_CHAIN(P,i,j);
begin
  if i=j then return(0);
  m[i,j]:=∞;
  for k:=i to j-1 do
    begin
      q:=RECURSIVE_MATRIX_CHAIN(P,i,k)+RECURSIVE_MATRIX_CHAIN(P,k+1,j)+pi-1pkpj;
      if q
    end
  return(m[i,j]);
end;

因此，直接递归算法RECURSIVE_MATRIX_CHAIN(P,1,n)的计算时间随n指数增长。相比之下，解同一问题的动态规划算法MATRIX_CHAIN_ORDER (P,1,n)只需计算时间O(n2)。其有效性就在于它充分利用了问题的子问题重叠性质。不同的子问题个数为θ(n2)，而动态规划算法对于每个不同的子问题只计算一次，不是重复计算多次。由此也可看出，当解某一问题的直接递归算法所产生的递归树中，相同的子问题反复出现，并且不同子问题的个数又相对较少时，用动态规划算法是有效的。
备忘录方法
动态规划算法的一个变形是备忘录方法。与动态规划算法一样，备忘录方法用一个表格来保存已解决的子问题的答案，在再碰到该子问题时，只要简单地查看该子问题的解答，而不必重新求解。不同的是，备忘录方法采用的是自顶向下的递归方式，而动态规划算法采用的是自底向上的非递归方式。我们看到，备忘录方法的控制结构与直接递归方法的控制结构相同，区别仅在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。
备忘录方法为每个子问题建立一个记录项，初始化时，该记录项存入一个特殊的值，表示该子问题尚末求解。在求解过程中，对碰到的每个子问题，首先查看其相应的记录项。若记录项中存储的是初始化时存入的特殊值，则表示该子问题是第一次遇到，此时需要对该子问题进行求解，并把得到的解保存在其相应的记录项中，以备以后查看。若记录项中存储的巴不是初始化时存入的特殊值，则表示该子问题己被求解过，其相应的记录项中存储的是该子问题的解答。此时，只要从记录项中取出读子问题的解答即可，不必重新计算。
下面的算法MEMOIZED_MATRIX_CHAIN(P)是解矩阵连乘积最优计算次序问题的备忘录方法。
     
   Procedure MEMOIZED_MATRIX_CHAIN(P);
      begin
       n:=length[P]-1;
       for i:=1 to n do
         for j:=1 to n do
           m[i,j]:=∞;
       return(LOOKUP_CHAIN(P,l,n));
      end;
     
      Function LOOKUP_CHAIN(P,i,j);
      begin
       if m[i,j]<∞ then return(m[i,j]);
       if i=j the m[i,j]:=0
        else
         for k:=i to j-1 do
          begin
           q:=LOOKUP_CHAIN(P,i.,k)+LOOKUP_CHAIN(P,k+1,j)+pi-1pkpj;
           if q
          end;
        return(m[i,j]);
       end;     
与动态规划算法MATRIX_CHAIN_ORDER一样，备忘录算法MEMOIZED_ MATRIX_CHAIN用数组m[1…n,1…n]的单元m[i,j]来记录解子问题Ai…j的最优计算量。M[i,j]初始化为∞，表示相应于Ai…j的子问题还未被计算。在调用LOODKUP _CHAIN(P,i,j)时，若m[i,j]<∞，则表示m[i,j]中存储的是所要求子问题的计算结果，直接返回此结果即可。否则与直接递归算法一样，自顶向下地递归计算，并将计算结果存入m[i,j]后返回。因此，LOODKUP_CHAIN(P,i,j)总能正确返回m[i,j]的值，但仅在它第一次被调用时计算，以后的调用就直接返回计算结果。
与动态规划算法一样，备忘录算法MEMOIZED_MATRIX_CHAIN耗时O(n3)。事实上，共有O(n2)个备忘记录项m[i,j]，i=1,2,…,n , j=i,i+1,…n，这些记录项的初始化耗费O(n2)时间。每个记录项只填入一次，每次填入时，不包括填入其他记录项的时间，共耗费O(n)。因此，LOODKUP_CHAIN(P,1,n)填入O(n2)个记录项总共耗费O(n3)计算时间。由此可见，通过使用备忘录技术，直接递归算法的计算时间从仍Ω(2n)降至O(n3)。
综上所述，矩阵连乘积的最优计算次序问题可用自顶向下的备忘录算法或自底向上的动态规划算法在O(n3)时间内求解。这两个算法都利用了子问题重叠性质。总共有θ(n2)个不同的子问题。对每个子问题，两种方法都只解一次，并记录答案，再碰到该问题时，不重新求解而简单地取用已得到的答案。因此，节省了计算量，提高了算法的效率。
一般地讲，当一个问题的所有子问题都至少要解一次时，用动态规划算法解比用备忘录方法好。此时，动态规划算法没有任何多余的计算。同时，对于许多问题，常可利用其规则的表格存取方式，来减少在动态规划算法中的计算时间和空间需求。当子问题空间中的部分子问题可不必求解时，用备忘录方法则较有利，因为从其控制结构可以看出，该方法只解那些确实需要求解的子问题。
例3  最长公共子序列问题LCS
问题描述   一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=<x1, x2,…, xm>，则另一序列Z=<z1, z2,…, zk>是X的子序列是指存在一个严格递增的下标序列 <i1, i2,…, ik>，使得对于所有j=1,2,…,k有
例如，序列Z=是序列X=的子序列，相应的递增下标序列为<2,3,5,7>。
给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例如，若X=和Y=，则序列是X和Y的一个公共子序列，序列也是X和Y的一个公共子序列。而且，后者是X和Y的一个最长公共子序列，因为X和Y没有长度大于4的公共子序列。
最长公共子序列(LCS)问题：给定两个序列X=<x1, x2, …, xm>和Y=<y1, y2, … , yn>，要求找出X和Y的一个最长公共子序列。
参考解答   动态规划算法可有效地解此问题。下面我们按照动态规划算法设计的各个步骤来设计一个解此问题的有效, 算法。
1.最长公共子序列的结构
解最长公共子序列问题时最容易想到的算法是穷举搜索法，即对X的每一个子序列，检查它是否也是Y的子序列，从而确定它是否为X和Y的公共子序列，并且在检查过程中选出最长的公共子序列。X的所有子序列都检查过后即可求出X和Y的最长公共子序列。X的一个子序列相应于下标序列{1, 2, …, m}的一个子序列，因此，X共有2m个不同子序列，从而穷举搜索法需要指数时间。
事实上，最长公共子序列问题也有最优子结构性质，因为我们有如下定理：
定理: LCS的最优子结构性质
设序列X=1, x2, …, xm>和Y=1, y2, …, yn>的一个最长公共子序列Z=1, z2, …, zk>，则：
若xm=yn，则zk=xm=yn且Zk-1是Xm-1和Yn-1的最长公共子序列；
若xm≠yn且zk≠xm ，则Z是Xm-1和Y的最长公共子序列；
若xm≠yn且zk≠yn ，则Z是X和Yn-1的最长公共子序列。
其中Xm-1=1, x2, …, xm-1>，Yn-1=1, y2, …, yn-1>，Zk-1=1, z2, …, zk-1>。
证明   用反证法。若zk≠xm，则1, z2, …, zk ,xm >是X和Y的长度为k十1的公共子序列。这与Z是X和Y的一个最长公共子序列矛盾。因此，必有zk=xm=yn。由此可知Zk-1是Xm-1和Yn-1的一个长度为k-1的公共子序列。若Xm-1和Yn-1有一个长度大于k-1的公共子序列W，则将xm加在其尾部将产生X和Y的一个长度大于k的公共子序列。此为矛盾。故Zk-1是Xm-1和Yn-1的一个最长公共子序列。
由于zk≠xm，Z是Xm-1和Y的一个公共子序列。若Xm-1和Y有一个长度大于k的公共子序列W，则W也是X和Y的一个长度大于k的公共子序列。这与Z是X和Y的一个最长公共子序列矛盾。由此即知Z是Xm-1和Y的一个最长公共子序列。
与 2.类似。
这个定理告诉我们，两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。
2.子问题的递归结构
由最长公共子序列问题的最优子结构性质可知，要找出X=1, x2, …, xm>和Y=1, y2, …, yn>的最长公共子序列，可按以下方式递归地进行：当xm=yn时，找出Xm-1和Yn-1的最长公共子序列，然后在其尾部加上xm(=yn)即可得X和Y的一个最长公共子序列。当xm≠yn时，必须解两个子问题，即找出Xm-1和Y的一个最长公共子序列及X和Yn-1的一个最长公共子序列。这两个公共子序列中较长者即为X和Y的一个最长公共子序列。
由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如，在计算X和Y的最长公共子序列时，可能要计算出X和Yn-1及Xm-1和Y的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算Xm-1和Yn-1的最长公共子序列。
与矩阵连乘积最优计算次序问题类似，我们来建立子问题的最优值的递归关系。用c[i,j]记录序列Xi和Yj的最长公共子序列的长度。其中Xi=1, x2, …, xi>，Yj=1, y2, …, yj>。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列，故c[i,j]=0。其他情况下，由定理可建立递归关系如下：

3.计算最优值
直接利用(2.2)式容易写出一个计算c[i,j]的递归算法，但其计算时间是随输入长度指数增长的。由于在所考虑的子问题空间中，总共只有θ(m*n)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。
计算最长公共子序列长度的动态规划算法LCS_LENGTH(X,Y)以序列X=1, x2, …, xm>和Y=1, y2, …, yn>作为输入。输出两个数组c[0..m ,0..n]和b[1..m ,1..n]。其中c[i,j]存储Xi与Yj的最长公共子序列的长度，b[i,j]记录指示c[i,j]的值是由哪一个子问题的解达到的，这在构造最长公共子序列时要用到。最后，X和Y的最长公共子序列的长度记录于c[m,n]中。
Procedure LCS_LENGTH(X,Y);
begin
  m:=length[X];
  n:=length[Y];
  for i:=1 to m do c[i,j]:=0;
  for j:=1 to n do c[0,j]:=0;
  for i:=1 to m do
    for j:=1 to n do
      if x[i]=y[j] then
        begin
          c[i,j]:=c[i-1,j-1]+1;
          b[i,j]:="↖";
        end
      else if c[i-1,j]≥c[i,j-1] then
        begin
          c[i,j]:=c[i-1,j];
          b[i,j]:="↑";
        end
      else
        begin
          c[i,j]:=c[i,j-1];
          b[i,j]:="←"
        end;
  return(c,b);
end;
由于每个数组单元的计算耗费Ο(1)时间，算法LCS_LENGTH耗时Ο(mn)。
4.构造最长公共子序列
由算法LCS_LENGTH计算得到的数组b可用于快速构造序列X=1, x2, …, xm>和Y=1, y2, …, yn>的最长公共子序列。首先从b[m,n]开始，沿着其中的箭头所指的方向在数组b中搜索。当b[i,j]中遇到"↖"时，表示Xi与Yj的最长公共子序列是由Xi-1与Yj-1的最长公共子序列在尾部加上xi得到的子序列；当b[i,j]中遇到"↑"时，表示Xi与Yj的最长公共子序列和Xi-1与Yj的最长公共子序列相同；当b[i,j]中遇到"←"时，表示Xi与Yj的最长公共子序列和Xi与Yj-1的最长公共子序列相同。
下面的算法LCS(b,X,i,j)实现根据b的内容打印出Xi与Yj的最长公共子序列。通过算法的调用LCS(b,X,length[X],length[Y])，便可打印出序列X和Y的最长公共子序列。
Procedure LCS(b,X,i,j);
begin
  if i=0 or j=0 then return;
  if b[i,j]="↖" then
    begin
      LCS(b,X,i-1,j-1);
      print(x[i]); {打印x[i]}
    end
  else if b[i,j]="↑" then LCS(b,X,i-1,j)
                      else LCS(b,X,i,j-1);
end;
在算法LCS中，每一次的递归调用使i或j减1，因此算法的计算时间为O(m+n)。
例如，设所给的两个序列为X=和Y=。由算法LCS_LENGTH和LCS计算出的结果如图2所示。


图2   算法LCS的计算结果
5.算法的改进
对于一个具体问题，按照一般的算法设计策略设计出的算法，往往在算法的时间和空间需求上还可以改进。这种改进，通常是利用具体问题的一些特殊性。
例如，在算法LCS_LENGTH和LCS中，可进一步将数组b省去。事实上，数组元素c[i,j]的值仅由c[i-1,j-1]，c[i-1,j]和c[i,j-1]三个值之一确定，而数组元素b[i,j]也只是用来指示c[i,j]究竟由哪个值确定。因此，在算法LCS中，我们可以不借助于数组b而借助于数组c本身临时判断c[i,j]的值是由c[i-1,j-1]，c[i-1,j]和c[i,j-1]中哪一个数值元素所确定，代价是Ο(1)时间。既然b对于算法LCS不是必要的，那么算法LCS_LENGTH便不必保存它。这一来，可节省θ(mn)的空间，而LCS_LENGTH和LCS所需要的时间分别仍然是Ο(mn)和Ο(m+n)。不过，由于数组c仍需要Ο(mn)的空间，因此这里所作的改进，只是在空间复杂性的常数因子上的改进。
另外，如果只需要计算最长公共子序列的长度，则算法的空间需求还可大大减少。事实上，在计算c[i,j]时，只用到数组c的第i行和第i-1行。因此，只要用2行的数组空间就可以计算出最长公共子序列的长度。更进一步的分析还可将空间需求减至min(m, n)。
 
例4  凸多边形的最优三角剖分问题
问题描述
    多边形是平面上一条分段线性的闭曲线。也就是说，多边形是由一系列首尾相接的直线段组成的。组成多边形的各直线段称为该多边形的边。多边形相接两条边的连接点称为多边形的顶点。若多边形的边之间除了连接顶点外没有别的公共点，则称该多边形为简单多边形。一个简单多边形将平面分为3个部分：被包围在多边形内的所有点构成了多边形的内部；多边形本身构成多边形的边界；而平面上其余的点构成了多边形的外部。当一个简单多边形及其内部构成一个闭凸集时，称该简单多边形为凸多边形。也就是说凸多边形边界上或内部的任意两点所连成的直线段上所有的点均在该凸多边形的内部或边界上。
    通常，用多边形顶点的逆时针序列来表示一个凸多边形，即P=0 ,v1 ,… ,vn-1>表示具有n条边v0v1，v1v2，… ,vn-1vn的一个凸多边形，其中，约定v0=vn 。
    若vi与vj是多边形上不相邻的两个顶点，则线段vivj称为多边形的一条弦。弦 将多边形分割成凸的两个子多边形i ,vi+1 ,… ,vj>和j ,vj+1 ,… ,vi>。多边形的三角剖分是一个将多边形分割成互不重迭的三角形的弦的集合T。图1是一个凸多边形的两个不同的三角剖分。

图1 一个凸多边形的2个不同的三角剖分
    在凸多边形P的一个三角剖分T中，各弦互不相交且弦数已达到最大，即P的任一不在T中的弦必与T中某一弦相交。在一个有n个顶点的凸多边形的三角刮分中，恰好有n-3条弦和n-2个三角形。
    凸多边形最优三角剖分的问题是：给定一个凸多边形P=0 ,v1 ,… ,vn-1>以及定义在由多边形的边和弦组成的三角形上的权函数ω。要求确定该凸多边形的一个三角剖分，使得该三角剖分对应的权即剖分中诸三角形上的权之和为最小。
    可以定义三角形上各种各样的权函数W。例如：定义  ω(△vivjvk)=|vivj|+|vivk|+|vkvj|,其中，|vivj|是点vi到vj的欧氏距离。相应于此权函数的最优三角剖分即为最小弦长三角剖分。
注意：解决此问题的算法必须适用于任意的权函数。
参考解答
用动态规划算法也能有效地求解凸多边形的最优三角剖分问题。尽管这是一个计算几何学问题，但在本质上，它与矩阵连乘积的最优计算次序问题极为相似。
1.三角剖分的结构及其相关问题
    凸多边形的三角剖分与表达式的完全加括号方式之间具有十分紧密的联系。正如所看到过的，矩阵连乘积的最优计算次序问题等价于矩阵链的完全加括号方式。这些问题之间的相关性可从它们所对应的完全二叉树的同构性看出。这里的所谓完全二叉树是指叶结点以外的所有结点的度数都为2的二叉树(注意与满二叉树和近似满二叉树的区别)。
    一个表达式的完全加括号方式对应于一棵完全二叉树，人们称这棵二叉树为表达式的语法树。例如，与完全加括号的矩阵连乘积((A1(A2A3))(A4(A5A6)))相对应的语法树如图3(a)所示。

图3    表达式语法树与三角剖分的对应
    语法树中每一个叶子表示表达式中一个原子。在语法树中，若一结点有一个表示表达式E1的左子树，以及一个表示表达式Er的右子树，则以该结点为根的子树表示表达式(E1Er)。因此，有n个原子的完全加括号表达式对应于唯一的一棵有n个叶结点的语法树，反之亦然。
    凸多边形0 ,v1 ,… ,vn-1>的三角剖分也可以用语法树来表示。例如，图3(a)中凸多边形的三角剖分可用图3(b)所示的语法树来表示。该语法树的根结点为边v0v6，三角剖分中的弦组成其余的内部结点。多边形中除v0v6边外的每一条边是语法树的一个叶结点。树根v0v6是三角形v0v3v6的一条边，该三角形将原多边形分为3个部分：三角形v0v3v6，凸多边形0 ,v1 ,… ,v3>和凸多边形3 ,v4 ,… ,v6>。三角形v0v3v6的另外两条边，即弦v3v6和v0v3为根的两个儿子。以它们为根的子树分别表示凸多边形0 ,v1 ,… ,v3>和凸多边形3 ,v4 ,… ,v6>的三角剖分。
    在一般情况下，一个凸n边形的三角剖分对应于一棵有n-1个叶子的语法树。反之，也可根据一棵有n-1个叶子的语法树产生相应的一个凸n边形的三角剖分。也就是说，凸n边形的三角剖分与n-1个叶子的语法树之间存在一一对应关系。由于n个矩阵的完全加括号乘积与n个叶子的语法树之间存在一一对应关系，因此n个矩阵的完全加括号乘积也与凸(n+1)边形的三角剖分之间存在一一对应关系。图3的(a)和(b)表示出了这种对应关系，这时n=6。矩阵连乘积A1A2..A6中的每个矩阵Ai对应于凸(n+1)边形中的一条边vi-1vi。三角剖分中的一条弦vivj，ii+1..j 。
    事实上，矩阵连乘积的最优计算次序问题是凸多边形最优三角剖分问题的一个特殊情形。 对于给定的矩阵链A1A2..An，定义一个与之相应的凸(n+1)边形P=0 ,v1 ,… ,vn>，使得矩阵Ai与凸多边形的边vi-1vi一一对应。若矩阵Ai的维数为pi-1×pi,i=1,2,…,n，则定义三角形vivjvk上的权函数值为： ω(△vivjvk)=pipjpk。依此权函数的定义，凸多边形P的最优三角剖分所对应的语法树给出矩阵链A1A2..An的最优完全加括号方式。
2.最优子结构性质
    凸多边形的最优三角剖分问题有最优子结构性质。事实上，若凸(n+1)边形P=0 ,v1 ,… ,vn>的一个最优三角剖分T包含三角形v0vkvn ， 1≤k≤n-1，则T的权为3个部分权的和，即三角形v0vkvn的权，子多边形0 ,v1 ,… ,vk>的权和k ,vk+1 ,… ,vn>的权之和。可以断言由T所确定的这两个子多边形的三角剖分也是最优的，因为若有0 ,v1 ,… ,vk>或k ,vk+1 ,… ,vn>的更小权的三角剖分，将会导致T不是最优三角剖分的矛盾。
3.最优三角剖分对应的权的递归结构
    首先，定义t[i,j]，1≤ii-1 ,vi ,… ,vj>的最优三角剖分所对应的权值，即最优值。为方便起见，设退化的多边形i-1 ,vi>具有权值0。据此定义，要计算的凸(n+1)边多边形P对应的权的最优值为t[1,n]。
    t[i,j]的值可以利用最优子结构性质递归地计算。由于退化的2顶点多边形的权值为0，所以t[i,i]=0，i=1,2,…,n 。当j一i≥1时，子多边形i-1 ,vi ,… ,vj>至少有3个顶点。由最优于结构性质,t[i,j]的值应为t[i,k]的值加上t[k+1,j]的值，再加上△vi-1vkvj的权值，并在i≤k≤j-1的范围内取最小。由此，t[i,j]可递归地定义为：

4.计算最优值
    将(2.3)式与矩阵连乘积的最优计算次序问题中计算m[i,j]的(2.l)式进行比较容易看出，除了权函数的定义外，两个递归式是完全一样的。因此只要对计算m[i,j]的算法MATRIX_CHAIN_ORDER做很小的修改就完全适用于计算t[i,j]。
    下面描述的计算凸(n+1)边形P=0 ,v1 ,… ,vn>的三角剖分最优权值的动态规划算法MINIMUM_WEIGHT_TRIANGULATION，输入是凸多边形P=0 ,v1 ,… ,vn>的权函数ω，输出是最优值t[i,j]和使得t[i,k]+t[k+1,j]+ω(△vi-1vkvj)达到最优的位置(k=)s[i,j]，1≤i≤j≤n 。
Procedure MINIMUM_WEIGHT_TRIANGULATION(P,w)；
begin
  n:=length[p]-1;
  for i:=1 to n do t[i,i]:=0;
    for ll:=2 to n do
      for i:=1 to n-ll+1 do
        begin
          j:=i+ll-1;
          t[i,j]:=∞;
          for k:=i to j-1 do
            begin
              q:=t[i,k]+t[k+1,j]+ω(△vi-1vkvj);
              if q
                begin
                  t[i,j]:=q;
                  s[i,j]:=k;
                end;
            end;
        end;
  return(t,s);
end;
与MATRIX_CHAIN_ORDER一样，算法MINIMUM_WEIGHT_TRIANGULATION占用θ(n2)空间，耗时θ(n3)。
5.构造最优三角剖分
如我们所看到的，对于任意的1≤i≤j≤n ，算法MINIMUM_WEIGHT_TRIANGULATION在计算每一个子多边形i-1 ,vi ,… ,vj>的最优三角剖分所对应的权值t[i,j]的同时，还在s[i,j]中记录了此最优三角剖分中与边(或弦)vi-1vj构成的三角形的第三个顶点的位置。因此，利用最优子结构性质并借助于s[i,j]，1≤i≤j≤n ，凸(n+l)边形P=0 ,v1 ,… ,vn>的最优三角剖分可容易地在Ο(n)时间内构造出来。
 
例5  多边形计算 (IOI'98)
问题描述
Polygon is a game for one player that starts on a polygon with N vertices, like the one in Figure 1, where N=4. Each vertex is labelled with an integer and each edge is labelled with either the symbol + (addition) or the symbol * (product). The edges are numbered from 1 to N.

Figure 1. Graphical representation of a polygon
On the first move, one of the edges is removed.
Subsequent moves involve the following steps:
pick an edge E and the two vertices V_1 and V_2 that are linked by E; and
replace them by a new vertex, labelled with the result of performing the operation indicated in E on the labels of V_1 and V_2.
The game ends when there are no more edges, and its score is the label of the single vertex remaining.
Sample game
Consider the polygon of Figure 1. The player started by removing edge 3. The effects are depicted in Figure 2.

Task
Write a program that, given a polygon, computes the highest possible score and lists all the edges that, if removed on the first move, can lead to a game with that score.
Input Data
File POLYGON.IN describes a polygon with N vertices. It contains two lines.
On the first line is the number N.
The second line contains the labels of edges 1, ..., N, interleaved with the vertices' labels (first that of the vertex between edges 1 and 2, then that of the vertex between edges 2 and 3, and so on, until that of the vertex between edges N and 1), all separated by one space. An edge label is either the letter t (representing +) or the letter x (representing *).
Sample Input
4
t -7 t 4 x 2 x 5
This is the input file for the polygon of Figure 1. The second line starts with the label of edge 1.
Output Data
On the first line of file POLYGON.OUT your program must write the highest score one can get for the input polygon.
On the second line it must write the list of all edges that, if removed on the first move, can lead to a game with that score.
Edges must be written in increasing order, separated by one space.
Sample Output
33
1 2
This must be the output file for the polygon of Figure 1.
Constraints
3 <= N <= 50
For any sequence of moves, vertex labels are in the range [-32768,32767].
参考解答
如果穷举解决此问题复杂性是n!，显然不可行。此问题看上去复杂，但是可以用动态规划很好地解决。
这个问题看上去好像不具有最优子结构，但是仔细分析一下还是可以利用动态规划的思想解决的。关键在于乘法运算同号得正，异号得负，如果a,b都是负数，a*b有可能得到一个很大的正数。因此需要同时保存子问题的最大值和最小值。
    以节点i为首按顺时针长度为L的链的计算结果最小值为Fmin(i,L)，最大值为Fmax(i,L)，联结第i个节点和其顺时针方向的下一个节点(i mod n)+1的边上的运算符记为opr(i)，则可以得到以下递归公式：


公式中(i+t)mod n +1 是节点i顺时针方向的第t+1个节点的编号，V(i)为节点i上标的数字，opr(i)为联结第i个节点和其顺时针方向的下一个节点(i mod n)+1的边上的运算符。根据这个公式，我们可以递推求出所有的F(i,n),i=1,2,..,n，其中的最大值就是所求。
    这道题已经不是很标准的动态规划了，但是它利用了动态规划的基本思想，分治和解决冗余。
 
例6  字符识别 (IOI'97)
问题描述 （英文原题）
这个题目需要你编写一个字符识别程序。
具体内容
每一个假设的字符图像(字符点阵)有20行，每行有20个"0"或"1"的数字。
FONT.DAT文件中有27个按照下列顺序排列的字符图像：
□abcdefghijklmnopqrstuvwxyz
□在这里表示空格符。
文件IMAGE.DAT包含有一个或者多个被破损的字符图像，一个字符图形可能通过以下几种途径被破损：
至多有一行被复制(复制的行紧接其后)
至多有一行丢失
有些"0"可能变成"1"
有些"1"可能变成"0"
字符图像不会同时有一行被复制而同时又丢失一行，在测试数据中，任何一个字符图像弄反"0"和"1"的比例不超过30%。
在行被复制的情况中，复制行和被复制行都可能破损，但破损的情形可能是不同的。
任务
用FONT.DAT提供的字体对IMAGE.DAT文件中的一个或者多个字符序列进行识别。
在一种自己最满意的有关"行"被复制或丢失的假设下，根据实际字符图像和标准字符图像的比较，以"0"和"1"发生错误的总数越少越好为条件来识别给定的字符图像，题中所给的样例字符图像都会被一个好的程序所识别，对于一个被测数据组，有一个唯一的最佳解。
正确解应该准确使用由输入文件IMAGE.DAT所提供的所有行数。
输入
两个输入文件都由整数N(19≤N≤1200)开始，该整数指出下面的行数。
 
N
(digit1)(digit2)(digit3) … (digit20)
(digit1)(digit2)(digit3) … (digit20)
…
每一行的数据都有20个码，码和码之间没有空格。
文件FONT.DAT描述字体。FONT.DAT总是包含541行。每次FONT.DAT都可能是不同的。
输出
你的程序必须生成一个IMAGE.OUT文件。它应该包含一串识别出的字符。它的格式是一行ASCII码。输出结果不应含有任何分隔符，如果你的程序识别不出一个字符，则在相应的位置显示"?"。
警告：上述输出格式不遵守在规则中规定的在输出的结果中留出空格的规定。
计分：根据正确识别出的字符的比例确定所得分数。
Incomplete sample showing the beginning of FONT.DAT (space and 'a'). 
Sample IMAGE.DAT, showing an 'a' corrupted 
FONT.DAT 
IMAGE.DAT 
540
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000011100000000000 
00000111111011000000 
00001111111001100000 
00001110001100100000 
00001100001100010000 
00001100000100010000 
00000100000100010000 
00000010000000110000 
00000001000001110000 
00001111111111110000 
00001111111111110000 
00001111111111000000 
00001000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000000000000000000 
19 
00000000000000000000 
00000000000000000000 
00000000000000000000 
00000011100000000000 
00100111011011000000 
00001111111001100000 
00001110001100100000 
00001100001100010000 
00001100000100010000 
00000100000100010000 
00000010000000110000 
00001111011111110000 
00001111111111110000 
00001111111111000000 
00001000010000000000 
00000000000000000000 
00000000000001000000 
00000000000000000000 
00000000000000000000 
Figure 1a
Figure 1b
示例输出
IMAGE.OUT
Explanation 
a
Recognised the single character 'a' 
参考解答
此题要使用两次动态规划。具体解法暂缺。
可以参考来煜坤的论文把握本质，灵活运用——动态规划的深入探讨 (Zipped MS Word Document 57KB)
此题与高性能计算机的解法类似，请参考该题的解法。
 
 
 
九、动态规划的技巧——阶段的划分和状态的表示
在动态规划的设计过程中，阶段的划分和状态的表示是非常重要的两步，这两步会直接影响该问题的计算复杂性，有时候阶段划分或状态表示的不合理还会使得动态规划法不适用。
[例9] 街道问题
在下图中找出从左下角到右上角的最短路径，每步只能向右方或上方走。


[例10] LITTLE SHOP OF FLOWERS （IOI’99）
PROBLEM
You want to arrange the window of your flower shop in a most pleasant way. You have F bunches of flowers, each being of a different kind, and at least as many vases ordered in a row. The vases are glued onto the shelf and are numbered consecutively 1 through V, where V is the number of vases, from left to right so that the vase 1 is the leftmost, and the vase V is the rightmost vase. The bunches are moveable and are uniquely identified by integers between 1 and F. These id-numbers have a significance: They determine the required order of appearance of the flower bunches in the row of vases so that the bunch i must be in a vase to the left of the vase containing bunch j whenever i < j. Suppose, for example, you have a bunch of azaleas (id-number=1), a bunch of begonias (id-number=2) and a bunch of carnations (id-number=3). Now, all the bunches must be put into the vases keeping their id-numbers in order. The bunch of azaleas must be in a vase to the left of begonias, and the bunch of begonias must be in a vase to the left of carnations. If there are more vases than bunches of flowers then the excess will be left empty. A vase can hold only one bunch of flowers.
Each vase has a distinct characteristic (just like flowers do). Hence, putting a bunch of flowers in a vase results in a certain aesthetic value, expressed by an integer. The aesthetic values are presented in a table as shown below. Leaving a vase empty has an aesthetic value of 0.

According to the table, azaleas, for example, would look great in vase 2, but they would look awful in vase 4.
To achieve the most pleasant effect you have to maximize the sum of aesthetic values for the arrangement while keeping the required ordering of the flowers. If more than one arrangement has the maximal sum value, any one of them will be acceptable. You have to produce exactly one arrangement.
ASSUMPTIONS
1 <= F <= 100 where F is the number of the bunches of flowers. The bunches are numbered 1 through F.
F <= V <= 100 where V is the number of vases.
-50 <= Aij <= 50 where Aij is the aesthetic value obtained by putting the flower bunch i into the vase j.
INPUT
The input is a text file named flower.inp.
The first line contains two numbers: F, V.
The following F lines: Each of these lines contains V integers, so that Aij is given as the jth number on the (i+1)st line of the input file.
OUTPUT
The output must be a text file named flower.out consisting of two lines:
The first line will contain the sum of aesthetic values for your arrangement.
The second line must present the arrangement as a list of F numbers, so that the k’th number on this line identifies the vase in which the bunch k is put.
EXAMPLE

EVALUATION
Your program will be allowed to run 2 seconds.
No partial credit can be obtained for a test case.
本题虽然是IOI’99中较为简单的一题，但其中大有文章可作。说它简单，是因为它有序，因此我们一眼便可看出这题应该用动态规划来解决。但是，如何动态规划呢？如何划分阶段，又如何选择状态呢？
<方法1>
以花束的编号来划分阶段。在这里，第k阶段布置第k束花，共有F束花，有F+1个阶段，增加第F+1阶段是为了计算的方便；状态变量xk表示第k束花所在的花瓶。而对于每一个状态xk，决策uk就是第k+1束花放置的花瓶号；最优指标函数fk(xk)表示从第k束花到第n束花所得到的最大美学值；A(i,j)是花束i插在花瓶j中的美学值,V是花瓶总数,F是花的总数。

方法1的规划方程中的允许决策空间：xk+1≤uk≤V-(F-k)+1 比较麻烦，因此有待改进。还是以花束的编号来划分阶段，第k阶段布置第k束花；状态变量xk表示第k束花所在的花瓶；注意，这里我们考虑倒过来布置花瓶，即从第F束花开始布置到第1束花。于是状态变量uk表示第k-1束花所在的花瓶；最优指标fk(xk)表示从第一束花到第k束花所获得的美学价值；A(i,j)是花束i插在花瓶j中的美学值,V是花瓶总数,F是花的总数。则状态转移方程为：

三种不同的方法都成功地解决了问题，只不过因为阶段的划分不同，状态的表示不同，决策的选择有多有少，所以算法的时间复杂度也就不同。
这个例子具有很大的普遍性。有很多的多阶段决策问题都有着不止一种的阶段划分方法，因而往往就有不止一种的规划方法。有时各种方法所产生的效果是差不多的，但更多的时候，就像我们的例子一样，两种方法会在某个方面有些区别。所以，在用动态规划解题的时候，可以多想一想是否有其它的解法。对于不同的解法，要注意比较，好的算法好在哪里，差一点的算法差在哪里。从各种不同算法的比较中，我们可以更深刻地领会动态规划的构思技巧。
 
动态规划实现中的问题
应用动态规划解决问题，在有了基本的思路之后，一般来说，算法实现是比较好考虑的。但有时也会遇到一些问题，而使算法难以实现。动态规划思想设计的算法从整体上来看基本都是按照得出的递推关系式进行递推，这种递推相对于计算机来说，只要设计得当，效率往往是比较高的，这样在时间上溢出的可能性不大，而相反地，动态规划需要很大的空间以存储中间产生的结果，这样可以使包含同一个子问题的所有问题共用一个子问题解，从而体现动态规划的优越性，但这是以牺牲空间为代价的，为了有效地访问已有结果，数据也不易压缩存储，因而空间矛盾是比较突出的。另一方面，动态规划的高时效性往往要通过大的测试数据体现出来（以与搜索作比较），因而，对于大规模的问题如何在基本不影响运行速度的条件下，解决空间溢出的问题，是动态规划解决问题时一个普遍会遇到的问题。
对于这个问题，可以考虑从以下一些方面去尝试：
一个思考方向是尽可能少占用空间。如从结点的数据结构上考虑，仅仅存储必不可少的内容，以及数据存储范围上精打细算(按位存储、压缩存储等)。当然这要因问题而异，进行分析。另外，在实现动态规划时，一个我们经常采用的方法是用一个与结点数一样多的数组来存储每一步的决策，这对于倒推求得一种实现最优解的方法是十分方便的，而且处理速度也有一些提高。但是在内存空间紧张的情况下，我们就应该抓住问题的主要矛盾。省去这个存储决策的数组，而改成在从最优解逐级倒推时，再计算一次，选择某个可能达到这个值的上一阶段的状态，直到推出结果为止。这样做，在程序编写上比上一种做法稍微多花一点时间，运行的时效也可能会有一些(但往往很小)的下降，但却换来了很多的空间。因而这种思想在处理某些问题时，是很有意义的。
但有时，即使采用这样的方法也会发现空间溢出的问题。这时就要分析，这些保留下来的数据是否有必要同时存在于内存之中。因为有很多问题，动态规划递推在处理后面的内容时，前面比较远处的内容实际上是用不着的。对于这类问题，在已经确信不会再被使用的数据上覆盖数据，从而使空间得以重复利用，如果能有效地使用这一手段，对于相当大规模的问题，空间也不至于溢出（为了求出最优方案，保留每一步的决策仍是必要的，这同样需要空间）。
一般地说，这种方法可以通过两种思路来实现：一种是递推结果仅使用Data1和Data2这样两个数组，每次将Data1作为上一阶段，推得Data2数组，然后，将Data2通过复制覆盖到Data1之上，如此反复，即可推得最终结果。这种做法有一个局限性，就是对于递推与前面若干阶段相关的问题，这种做法就比较麻烦；而且，每递推一级，就需要复制很多的内容，与前面多个阶段相关的问题影响更大。另外一种实现方法是，对于一个可能与前N个阶段相关的问题，建立数组Data[0..N]，其中各项为最近N各阶段的保存数据。这样不采用这种内存节约方式时对于阶段k的访问只要对应成对数组Data中下标为k mod (N+1)的单元的访问就可以了。这种处理方法对于程序修改的代码很少，速度几乎不受影响，而且需要保留不同的阶段数也都能很容易实现。
当采用以上方法仍无法解决内存问题时，也可以采用对内存的动态申请来使绝大多数情况能有效出解。而且，使用动态内存还有一点好处，就是在重复使用内存而进行交换时，可以只对指针进行交换，而不复制数据，这在实践中也是十分有效的。
